/**
 *  @file   pathUtils.hpp
 *  @brief  This file implements path-related utilities.
 *  @author Eryk Roszkowski
 ***********************************************/

// Fully generated by AI. all stackoverflow solutions succked ass

#pragma once
#include <filesystem>
#include <string>

#include "errorUtils.hpp"

#ifdef _WIN32
#include <windows.h>
#elif defined(__APPLE__)
#include <mach-o/dyld.h>
#include <sys/param.h> // For MAXPATHLEN
#else // Linux
#include <unistd.h>
#endif

/// @brief Internal storage for the Asset Root override (Used by Editor)
inline std::string& GetAssetRootOverride() {
    static std::string path = "";
    return path;
}

/// @brief Called by the Editor to force GetAssetPath to look in the Project folder
inline void SetAssetRoot(const std::string& projectPath) {
    GetAssetRootOverride() = projectPath;
}

/// @brief Get the directory of the executable.
inline std::filesystem::path GetExecutableDir() {
    std::filesystem::path exePath;

#ifdef _WIN32
    // Windows: Use GetModuleFileNameW
    wchar_t wPath[MAX_PATH];
    DWORD len = GetModuleFileNameW(NULL, wPath, MAX_PATH);
    if (len == 0 || len == MAX_PATH) {
        vex::throw_error("Failed to get executable path on Windows");
    }
    // Convert UTF-16 to UTF-8
    int utf8Size = WideCharToMultiByte(CP_UTF8, 0, wPath, -1, nullptr, 0, nullptr, nullptr);
    if (utf8Size == 0) {
        vex::throw_error("Failed to convert executable path to UTF-8");
    }
    std::string utf8Path(utf8Size, '\0');
    WideCharToMultiByte(CP_UTF8, 0, wPath, -1, utf8Path.data(), utf8Size, nullptr, nullptr);
    exePath = std::filesystem::path(utf8Path);
#elif defined(__APPLE__)
    // macOS: Use _NSGetExecutablePath
    char pathBuf[MAXPATHLEN];
    uint32_t size = sizeof(pathBuf);
    if (_NSGetExecutablePath(pathBuf, &size) != 0) {
        vex::throw_error("Failed to get executable path on macOS");
    }
    exePath = std::filesystem::canonical(pathBuf); // Resolve symlinks/aliases
#else
    // Linux: Use readlink
    char pathBuf[1024];
    ssize_t len = ::readlink("/proc/self/exe", pathBuf, sizeof(pathBuf) - 1);
    if (len == -1) {
        vex::throw_error("Failed to read /proc/self/exe on Linux");
    }
    pathBuf[len] = '\0';
    exePath = std::filesystem::path(pathBuf);
#endif

    return exePath.parent_path();
}

/// @brief Get the path of an asset. Its different for debug and release builds since VirtualFileSystem implements asset loading differently depending on build type.
inline std::string GetAssetPath(const std::string& relativePath) {

    const std::string& overridePath = GetAssetRootOverride();
    if (!overridePath.empty()) {
        return (std::filesystem::path(overridePath) / relativePath).string();
    }

    #if DEBUG
        static std::filesystem::path exeDir = GetExecutableDir();
        return (exeDir / relativePath).string();
    #else
        return relativePath;
    #endif
}
