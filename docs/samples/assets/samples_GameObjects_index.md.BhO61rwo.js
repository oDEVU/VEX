import{_ as t,c as a,o,ae as n}from"./chunks/framework.70bNUV4I.js";const i="/VEX/samples/assets/GameObjects.i4PHuCWV.png",p=JSON.parse('{"title":"GameObject","description":"","frontmatter":{},"headers":[],"relativePath":"samples/GameObjects/index.md","filePath":"samples/GameObjects/index.md"}'),r={name:"samples/GameObjects/index.md"};function s(c,e,l,d,m,h){return o(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="gameobject" tabindex="-1">GameObject <a class="header-anchor" href="#gameobject" aria-label="Permalink to &quot;GameObject&quot;">​</a></h1><h2 id="the-foundation" tabindex="-1">The Foundation <a class="header-anchor" href="#the-foundation" aria-label="Permalink to &quot;The Foundation&quot;">​</a></h2><p>Everything in the scene is a <code>GameObject</code>. Unlike pure data containers, GameObjects in this engine are fully functional classes that serve as the &quot;Brain&quot; of your entity.</p><p>When you create a complex object (like a Player), you inherit from GameObject and write your custom logic inside standard lifecycle functions:</p><ul><li><p><code>BeginPlay()</code>: Runs once when the object is created.</p></li><li><p><code>Update(float deltaTime)</code>: Runs every frame (for movement, input, etc.).</p></li></ul><p>However, you don&#39;t need to write code for everything. For standard features, you attach Components to the GameObject. For example, a Player class handles the input logic, but relies on an attached MeshComponent to be seen and a PhysicsComponent to collide with walls.</p><hr><h2 id="editor-workflow" tabindex="-1">Editor Workflow <a class="header-anchor" href="#editor-workflow" aria-label="Permalink to &quot;Editor Workflow&quot;">​</a></h2><p>Your custom classes can be registered within the engine. Then you can find them in the Game Object Menu and drop them directly into your scene.</p><p><img src="'+i+'" alt="VEX Game Object Menu"></p>',10)])])}const f=t(r,[["render",s]]);export{p as __pageData,f as default};
