<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VEX Engine: Zstandard Compression Format</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="RenderedLogoLowRes.png"/></td>
  <td id="projectalign">
   <div id="projectname">VEX Engine
   </div>
   <div id="projectbrief">Retro looking game engine made in vulkan mostly because i wanted to understand it better.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_Core_2bin_2Debug_2__deps_2zstd-src_2doc_2zstd__compression__format.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Zstandard Compression Format </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2 class="doxsection"><a class="anchor" id="autotoc_md88"></a>
Notices</h2>
<p>Copyright (c) Meta Platforms, Inc. and affiliates.</p>
<p>Permission is granted to copy and distribute this document for any purpose and without charge, including translations into other languages and incorporation into compilations, provided that the copyright notice and this notice are preserved, and that any substantive changes or deletions from the original are clearly marked. Distribution of this document is unlimited.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md89"></a>
Version</h2>
<p>0.4.3 (2024-10-07)</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md90"></a>
Introduction</h1>
<p>The purpose of this document is to define a lossless compressed data format, that is independent of CPU type, operating system, file system and character set, suitable for file compression, pipe and streaming compression, using the <a href="https://facebook.github.io/zstd/">Zstandard algorithm</a>. The text of the specification assumes a basic background in programming at the level of bits and other primitive data representations.</p>
<p>The data can be produced or consumed, even for an arbitrarily long sequentially presented input data stream, using only an a priori bounded amount of intermediate storage, and hence can be used in data communications. The format uses the Zstandard compression method, and optional <a href="https://cyan4973.github.io/xxHash/">xxHash-64 checksum method</a>, for detection of data corruption.</p>
<p>The data format defined by this specification does not attempt to allow random access to compressed data.</p>
<p>Unless otherwise indicated below, a compliant compressor must produce data sets that conform to the specifications presented here. It doesn’t need to support all options though.</p>
<p>A compliant decompressor must be able to decompress at least one working set of parameters that conforms to the specifications presented here. It may also ignore informative fields, such as checksum. Whenever it does not support a parameter defined in the compressed stream, it must produce a non-ambiguous error code and associated error message explaining which parameter is unsupported.</p>
<p>This specification is intended for use by implementers of software to compress data into Zstandard format and/or decompress data from Zstandard format. The Zstandard format is supported by an open source reference implementation, written in portable C, and available at : <a href="https://github.com/facebook/zstd">https://github.com/facebook/zstd</a> .</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md91"></a>
Overall conventions</h2>
<p>In this document:</p><ul>
<li>square brackets i.e. <span class="tt">[</span> and <span class="tt">]</span> are used to indicate optional fields or parameters.</li>
<li>the naming convention for identifiers is <span class="tt">Mixed_Case_With_Underscores</span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md92"></a>
Definitions</h2>
<p>Content compressed by Zstandard is transformed into a Zstandard <b>frame</b>. Multiple frames can be appended into a single file or stream. A frame is completely independent, has a defined beginning and end, and a set of parameters which tells the decoder how to decompress it.</p>
<p>A frame encapsulates one or multiple <b>blocks</b>. Each block contains arbitrary content, which is described by its header, and has a guaranteed maximum content size, which depends on frame parameters. Unlike frames, each block depends on previous blocks for proper decoding. However, each block can be decompressed without waiting for its successor, allowing streaming operations.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md93"></a>
Overview</h1>
<ul>
<li>Frames<ul>
<li>Zstandard frames<ul>
<li>Blocks<ul>
<li>Literals Section</li>
<li>Sequences Section</li>
<li>Sequence Execution</li>
</ul>
</li>
</ul>
</li>
<li>Skippable frames</li>
</ul>
</li>
<li>Entropy Encoding<ul>
<li>FSE</li>
<li>Huffman Coding</li>
</ul>
</li>
<li>Dictionary Format</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md94"></a>
Frames</h1>
<p>Zstandard compressed data is made of one or more <b>frames</b>. Each frame is independent and can be decompressed independently of other frames. The decompressed content of multiple concatenated frames is the concatenation of each frame decompressed content.</p>
<p>There are two frame formats defined by Zstandard: Zstandard frames and Skippable frames. Zstandard frames contain compressed data, while skippable frames contain custom user metadata.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md95"></a>
Zstandard frames</h1>
<p>The structure of a single Zstandard frame is following:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><span class="tt">Magic_Number</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Frame_Header</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Data_Block</span>  </th><th class="markdownTableHeadNone">[More data blocks]  </th><th class="markdownTableHeadCenter">[<span class="tt">Content_Checksum</span>]  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">4 bytes  </td><td class="markdownTableBodyCenter">2-14 bytes  </td><td class="markdownTableBodyCenter">n bytes  </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyCenter">0-4 bytes  </td></tr>
</table>
<p><b><span class="tt">Magic_Number</span></b></p>
<p>4 Bytes, <b>little-endian</b> format. Value : 0xFD2FB528 Note: This value was selected to be less probable to find at the beginning of some random file. It avoids trivial patterns (0x00, 0xFF, repeated bytes, increasing bytes, etc.), contains byte values outside of ASCII range, and doesn't map into UTF8 space. It reduces the chances that a text file represent this value by accident.</p>
<p><b><span class="tt">Frame_Header</span></b></p>
<p>2 to 14 Bytes, detailed in `Frame_Header`.</p>
<p><b><span class="tt">Data_Block</span></b></p>
<p>Detailed in `Blocks`. That’s where compressed data is stored.</p>
<p><b><span class="tt">Content_Checksum</span></b></p>
<p>An optional 32-bit checksum, only present if <span class="tt">Content_Checksum_flag</span> is set. The content checksum is the result of <a href="https://cyan4973.github.io/xxHash/">xxh64() hash function</a> digesting the original (decoded) data as input, and a seed of zero. The low 4 bytes of the checksum are stored in <b>little-endian</b> format.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md96"></a>
<span class="tt">Frame_Header</span></h2>
<p>The <span class="tt">Frame_Header</span> has a variable size, with a minimum of 2 bytes, and up to 14 bytes depending on optional parameters. The structure of <span class="tt">Frame_Header</span> is following:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Frame_Header_Descriptor</span>  </th><th class="markdownTableHeadNone">[<span class="tt">Window_Descriptor</span>]  </th><th class="markdownTableHeadNone">[<span class="tt">Dictionary_ID</span>]  </th><th class="markdownTableHeadNone">[<span class="tt">Frame_Content_Size</span>]  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 byte  </td><td class="markdownTableBodyNone">0-1 byte  </td><td class="markdownTableBodyNone">0-4 bytes  </td><td class="markdownTableBodyNone">0-8 bytes  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md97"></a>
<span class="tt">Frame_Header_Descriptor</span></h3>
<p>The first header's byte is called the <span class="tt">Frame_Header_Descriptor</span>. It describes which other fields are present. Decoding this byte is enough to tell the size of <span class="tt">Frame_Header</span>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bit number  </th><th class="markdownTableHeadNone">Field name  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7-6  </td><td class="markdownTableBodyNone"><span class="tt">Frame_Content_Size_flag</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone"><span class="tt">Single_Segment_flag</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone"><span class="tt">Unused_bit</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone"><span class="tt">Reserved_bit</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone"><span class="tt">Content_Checksum_flag</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1-0  </td><td class="markdownTableBodyNone"><span class="tt">Dictionary_ID_flag</span>  </td></tr>
</table>
<p>In this table, bit 7 is the highest bit, while bit 0 is the lowest one.</p>
<p><b><span class="tt">Frame_Content_Size_flag</span></b></p>
<p>This is a 2-bits flag (<span class="tt">= Frame_Header_Descriptor &gt;&gt; 6</span>), specifying if <span class="tt">Frame_Content_Size</span> (the decompressed data size) is provided within the header. <span class="tt">Flag_Value</span> provides <span class="tt">FCS_Field_Size</span>, which is the number of bytes used by <span class="tt">Frame_Content_Size</span> according to the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Flag_Value</span>  </th><th class="markdownTableHeadNone">0  </th><th class="markdownTableHeadNone">1  </th><th class="markdownTableHeadNone">2  </th><th class="markdownTableHeadNone">3  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">FCS_Field_Size</span>  </td><td class="markdownTableBodyNone">0 or 1  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">8  </td></tr>
</table>
<p>When <span class="tt">Flag_Value</span> is <span class="tt">0</span>, <span class="tt">FCS_Field_Size</span> depends on <span class="tt">Single_Segment_flag</span> : if <span class="tt">Single_Segment_flag</span> is set, <span class="tt">FCS_Field_Size</span> is 1. Otherwise, <span class="tt">FCS_Field_Size</span> is 0 : <span class="tt">Frame_Content_Size</span> is not provided.</p>
<p><b><span class="tt">Single_Segment_flag</span></b></p>
<p>If this flag is set, data must be regenerated within a single continuous memory segment.</p>
<p>In this case, <span class="tt">Window_Descriptor</span> byte is skipped, but <span class="tt">Frame_Content_Size</span> is necessarily present. As a consequence, the decoder must allocate a memory segment of size equal or larger than <span class="tt">Frame_Content_Size</span>.</p>
<p>In order to preserve the decoder from unreasonable memory requirements, a decoder is allowed to reject a compressed frame which requests a memory size beyond decoder's authorized range.</p>
<p>For broader compatibility, decoders are recommended to support memory sizes of at least 8 MB. This is only a recommendation, each decoder is free to support higher or lower limits, depending on local limitations.</p>
<p><b><span class="tt">Unused_bit</span></b></p>
<p>A decoder compliant with this specification version shall not interpret this bit. It might be used in any future version, to signal a property which is transparent to properly decode the frame. An encoder compliant with this specification version must set this bit to zero.</p>
<p><b><span class="tt">Reserved_bit</span></b></p>
<p>This bit is reserved for some future feature. Its value <em>must be zero</em>. A decoder compliant with this specification version must ensure it is not set. This bit may be used in a future revision, to signal a feature that must be interpreted to decode the frame correctly.</p>
<p><b><span class="tt">Content_Checksum_flag</span></b></p>
<p>If this flag is set, a 32-bits <span class="tt">Content_Checksum</span> will be present at frame's end. See <span class="tt">Content_Checksum</span> paragraph.</p>
<p><b><span class="tt">Dictionary_ID_flag</span></b></p>
<p>This is a 2-bits flag (<span class="tt">= FHD &amp; 3</span>), telling if a dictionary ID is provided within the header. It also specifies the size of this field as <span class="tt">DID_Field_Size</span>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Flag_Value</span>  </th><th class="markdownTableHeadNone">0  </th><th class="markdownTableHeadNone">1  </th><th class="markdownTableHeadNone">2  </th><th class="markdownTableHeadNone">3  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">DID_Field_Size</span>  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">4  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md98"></a>
<span class="tt">Window_Descriptor</span></h3>
<p>Provides guarantees on minimum memory buffer required to decompress a frame. This information is important for decoders to allocate enough memory.</p>
<p>The <span class="tt">Window_Descriptor</span> byte is optional. When <span class="tt">Single_Segment_flag</span> is set, <span class="tt">Window_Descriptor</span> is not present. In this case, <span class="tt">Window_Size</span> is <span class="tt">Frame_Content_Size</span>, which can be any value from 0 to 2^64-1 bytes (16 ExaBytes).</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bit numbers  </th><th class="markdownTableHeadNone">7-3  </th><th class="markdownTableHeadNone">2-0  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field name  </td><td class="markdownTableBodyNone"><span class="tt">Exponent</span>  </td><td class="markdownTableBodyNone"><span class="tt">Mantissa</span>  </td></tr>
</table>
<p>The minimum memory buffer size is called <span class="tt">Window_Size</span>. It is described by the following formulas : </p><div class="fragment"><div class="line">windowLog = 10 + Exponent;</div>
<div class="line">windowBase = 1 &lt;&lt; windowLog;</div>
<div class="line">windowAdd = (windowBase / 8) * Mantissa;</div>
<div class="line">Window_Size = windowBase + windowAdd;</div>
</div><!-- fragment --><p> The minimum <span class="tt">Window_Size</span> is 1 KB. The maximum <span class="tt">Window_Size</span> is <span class="tt">(1&lt;&lt;41) + 7*(1&lt;&lt;38)</span> bytes, which is 3.75 TB.</p>
<p>In general, larger <span class="tt">Window_Size</span> tend to improve compression ratio, but at the cost of memory usage.</p>
<p>To properly decode compressed data, a decoder will need to allocate a buffer of at least <span class="tt">Window_Size</span> bytes.</p>
<p>In order to preserve decoder from unreasonable memory requirements, a decoder is allowed to reject a compressed frame which requests a memory size beyond decoder's authorized range.</p>
<p>For improved interoperability, it's recommended for decoders to support <span class="tt">Window_Size</span> of up to 8 MB, and it's recommended for encoders to not generate frame requiring <span class="tt">Window_Size</span> larger than 8 MB. It's merely a recommendation though, decoders are free to support larger or lower limits, depending on local limitations.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md99"></a>
<span class="tt">Dictionary_ID</span></h3>
<p>This is a variable size field, which contains the ID of the dictionary required to properly decode the frame. <span class="tt">Dictionary_ID</span> field is optional. When it's not present, it's up to the decoder to know which dictionary to use.</p>
<p><span class="tt">Dictionary_ID</span> field size is provided by <span class="tt">DID_Field_Size</span>. <span class="tt">DID_Field_Size</span> is directly derived from value of <span class="tt">Dictionary_ID_flag</span>. 1 byte can represent an ID 0-255. 2 bytes can represent an ID 0-65535. 4 bytes can represent an ID 0-4294967295. Format is <b>little-endian</b>.</p>
<p>It's allowed to represent a small ID (for example <span class="tt">13</span>) with a large 4-bytes dictionary ID, even if it is less efficient.</p>
<p>A value of <span class="tt">0</span> has same meaning as no <span class="tt">Dictionary_ID</span>, in which case the frame may or may not need a dictionary to be decoded, and the ID of such a dictionary is not specified. The decoder must know this information by other means.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md100"></a>
<span class="tt">Frame_Content_Size</span></h3>
<p>This is the original (uncompressed) size. This information is optional. <span class="tt">Frame_Content_Size</span> uses a variable number of bytes, provided by <span class="tt">FCS_Field_Size</span>. <span class="tt">FCS_Field_Size</span> is provided by the value of <span class="tt">Frame_Content_Size_flag</span>. <span class="tt">FCS_Field_Size</span> can be equal to 0 (not present), 1, 2, 4 or 8 bytes.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">FCS_Field_Size</span>  </th><th class="markdownTableHeadNone"><a class="el" href="structRange.html">Range</a>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">unknown  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">0 - 255  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">256 - 65791  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0 - 2^32-1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">0 - 2^64-1  </td></tr>
</table>
<p><span class="tt">Frame_Content_Size</span> format is <b>little-endian</b>. When <span class="tt">FCS_Field_Size</span> is 1, 4 or 8 bytes, the value is read directly. When <span class="tt">FCS_Field_Size</span> is 2, <em>the offset of 256 is added</em>. It's allowed to represent a small size (for example <span class="tt">18</span>) using any compatible variant.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md101"></a>
Blocks</h1>
<p>After <span class="tt">Magic_Number</span> and <span class="tt">Frame_Header</span>, there are some number of blocks. Each frame must have at least one block, but there is no upper limit on the number of blocks per frame.</p>
<p>The structure of a block is as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><span class="tt">Block_Header</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Block_Content</span>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">3 bytes  </td><td class="markdownTableBodyCenter">n bytes  </td></tr>
</table>
<p><b><span class="tt">Block_Header</span></b></p>
<p><span class="tt">Block_Header</span> uses 3 bytes, written using <b>little-endian</b> convention. It contains 3 fields :</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><span class="tt">Last_Block</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Block_Type</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Block_Size</span>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">bit 0  </td><td class="markdownTableBodyCenter">bits 1-2  </td><td class="markdownTableBodyCenter">bits 3-23  </td></tr>
</table>
<p><b><span class="tt">Last_Block</span></b></p>
<p>The lowest bit signals if this block is the last one. The frame will end after this last block. It may be followed by an optional <span class="tt">Content_Checksum</span> (see Zstandard Frames).</p>
<p><b><span class="tt">Block_Type</span></b></p>
<p>The next 2 bits represent the <span class="tt">Block_Type</span>. <span class="tt">Block_Type</span> influences the meaning of <span class="tt">Block_Size</span>. There are 4 block types :</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value  </th><th class="markdownTableHeadNone">0  </th><th class="markdownTableHeadNone">1  </th><th class="markdownTableHeadNone">2  </th><th class="markdownTableHeadNone">3  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Block_Type</span>  </td><td class="markdownTableBodyNone"><span class="tt">Raw_Block</span>  </td><td class="markdownTableBodyNone"><span class="tt">RLE_Block</span>  </td><td class="markdownTableBodyNone"><span class="tt">Compressed_Block</span>  </td><td class="markdownTableBodyNone"><span class="tt">Reserved</span>  </td></tr>
</table>
<ul>
<li><span class="tt">Raw_Block</span> - this is an uncompressed block. <span class="tt">Block_Content</span> contains <span class="tt">Block_Size</span> bytes.</li>
<li><span class="tt">RLE_Block</span> - this is a single byte, repeated <span class="tt">Block_Size</span> times. <span class="tt">Block_Content</span> consists of a single byte. On the decompression side, this byte must be repeated <span class="tt">Block_Size</span> times.</li>
<li><span class="tt">Compressed_Block</span> - this is a Zstandard compressed block, explained later on. <span class="tt">Block_Size</span> is the length of <span class="tt">Block_Content</span>, the compressed data. The decompressed size is not known, but its maximum possible value is guaranteed (see below)</li>
<li><span class="tt">Reserved</span> - this is not a block. This value cannot be used with current version of this specification. If such a value is present, it is considered corrupted data.</li>
</ul>
<p><b><span class="tt">Block_Size</span></b></p>
<p>The upper 21 bits of <span class="tt">Block_Header</span> represent the <span class="tt">Block_Size</span>.</p>
<p>When <span class="tt">Block_Type</span> is <span class="tt">Compressed_Block</span> or <span class="tt">Raw_Block</span>, <span class="tt">Block_Size</span> is the size of <span class="tt">Block_Content</span> (hence excluding <span class="tt">Block_Header</span>).</p>
<p>When <span class="tt">Block_Type</span> is <span class="tt">RLE_Block</span>, since <span class="tt">Block_Content</span>’s size is always 1, <span class="tt">Block_Size</span> represents the number of times this byte must be repeated.</p>
<p><span class="tt">Block_Size</span> is limited by <span class="tt">Block_Maximum_Size</span> (see below).</p>
<p><b><span class="tt">Block_Content</span></b> and <b><span class="tt">Block_Maximum_Size</span></b></p>
<p>The size of <span class="tt">Block_Content</span> is limited by <span class="tt">Block_Maximum_Size</span>, which is the smallest of:</p><ul>
<li><span class="tt">Window_Size</span></li>
<li>128 KB</li>
</ul>
<p><span class="tt">Block_Maximum_Size</span> is constant for a given frame. This maximum is applicable to both the decompressed size and the compressed size of any block in the frame.</p>
<p>The reasoning for this limit is that a decoder can read this information at the beginning of a frame and use it to allocate buffers. The guarantees on the size of blocks ensure that the buffers will be large enough for any following block of the valid frame.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md102"></a>
Compressed Blocks</h1>
<p>To decompress a compressed block, the compressed size must be provided from <span class="tt">Block_Size</span> field within <span class="tt">Block_Header</span>.</p>
<p>A compressed block consists of 2 sections :</p><ul>
<li>Literals Section</li>
<li>Sequences Section</li>
</ul>
<p>The results of the two sections are then combined to produce the decompressed data in Sequence Execution</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md103"></a>
Prerequisites</h3>
<p>To decode a compressed block, the following elements are necessary :</p><ul>
<li>Previous decoded data, up to a distance of <span class="tt">Window_Size</span>, or beginning of the Frame, whichever is smaller.</li>
<li>List of "recent offsets" from previous <span class="tt">Compressed_Block</span>.</li>
<li>The previous Huffman tree, required by <span class="tt">Treeless_Literals_Block</span> type</li>
<li>Previous FSE decoding tables, required by <span class="tt">Repeat_Mode</span> for each symbol type (literals lengths, match lengths, offsets)</li>
</ul>
<p>Note that decoding tables aren't always from the previous <span class="tt">Compressed_Block</span>.</p>
<ul>
<li>Every decoding table can come from a dictionary.</li>
<li>The Huffman tree comes from the previous <span class="tt">Compressed_Literals_Block</span>.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md104"></a>
Literals Section</h1>
<p>All literals are regrouped in the first part of the block. They can be decoded first, and then copied during [Sequence Execution], or they can be decoded on the flow during [Sequence Execution].</p>
<p>Literals can be stored uncompressed or compressed using Huffman prefix codes. When compressed, a tree description may optionally be present, followed by 1 or 4 streams.</p>
<p>| <span class="tt">Literals_Section_Header</span> | [<span class="tt">Huffman_Tree_Description</span>] | [jumpTable] | Stream1 | [Stream2] | [Stream3] | [Stream4] | | ----------------------&mdash; | -------------------------&mdash; | --------&mdash; | ----&mdash; | ------&mdash; | ------&mdash; | ------&mdash; |</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md105"></a>
<span class="tt">Literals_Section_Header</span></h2>
<p>Header is in charge of describing how literals are packed. It's a byte-aligned variable-size bitfield, ranging from 1 to 5 bytes, using <b>little-endian</b> convention.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Literals_Block_Type</span>  </th><th class="markdownTableHeadNone"><span class="tt">Size_Format</span>  </th><th class="markdownTableHeadNone"><span class="tt">Regenerated_Size</span>  </th><th class="markdownTableHeadNone">[<span class="tt">Compressed_Size</span>]  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2 bits  </td><td class="markdownTableBodyNone">1 - 2 bits  </td><td class="markdownTableBodyNone">5 - 20 bits  </td><td class="markdownTableBodyNone">0 - 18 bits  </td></tr>
</table>
<p>In this representation, bits on the left are the lowest bits.</p>
<p><b><span class="tt">Literals_Block_Type</span></b></p>
<p>This field uses 2 lowest bits of first byte, describing 4 different block types :</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Literals_Block_Type</span>  </th><th class="markdownTableHeadNone">Value  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Raw_Literals_Block</span>  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">RLE_Literals_Block</span>  </td><td class="markdownTableBodyNone">1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Compressed_Literals_Block</span>  </td><td class="markdownTableBodyNone">2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Treeless_Literals_Block</span>  </td><td class="markdownTableBodyNone">3  </td></tr>
</table>
<ul>
<li><span class="tt">Raw_Literals_Block</span> - Literals are stored uncompressed.</li>
<li><span class="tt">RLE_Literals_Block</span> - Literals consist of a single byte value repeated <span class="tt">Regenerated_Size</span> times.</li>
<li><span class="tt">Compressed_Literals_Block</span> - This is a standard Huffman-compressed block, starting with a Huffman tree description. In this mode, there are at least 2 different literals represented in the Huffman tree description. See details below.</li>
<li><span class="tt">Treeless_Literals_Block</span> - This is a Huffman-compressed block, using Huffman tree <em>from previous Huffman-compressed literals block</em>. <span class="tt">Huffman_Tree_Description</span> will be skipped. Note: If this mode is triggered without any previous Huffman-table in the frame (or dictionary), this should be treated as data corruption.</li>
</ul>
<p><b><span class="tt">Size_Format</span></b></p>
<p><span class="tt">Size_Format</span> is divided into 2 families :</p>
<ul>
<li>For <span class="tt">Raw_Literals_Block</span> and <span class="tt">RLE_Literals_Block</span>, it's only necessary to decode <span class="tt">Regenerated_Size</span>. There is no <span class="tt">Compressed_Size</span> field.</li>
<li>For <span class="tt">Compressed_Block</span> and <span class="tt">Treeless_Literals_Block</span>, it's required to decode both <span class="tt">Compressed_Size</span> and <span class="tt">Regenerated_Size</span> (the decompressed size). It's also necessary to decode the number of streams (1 or 4).</li>
</ul>
<p>For values spanning several bytes, convention is <b>little-endian</b>.</p>
<p><b><span class="tt">Size_Format</span> for <span class="tt">Raw_Literals_Block</span> and <span class="tt">RLE_Literals_Block</span></b> :</p>
<p><span class="tt">Size_Format</span> uses 1 <em>or</em> 2 bits. Its value is : <span class="tt">Size_Format = (Literals_Section_Header[0]&gt;&gt;2) &amp; 3</span></p>
<ul>
<li><span class="tt">Size_Format</span> == 00 or 10 : <span class="tt">Size_Format</span> uses 1 bit. <span class="tt">Regenerated_Size</span> uses 5 bits (0-31). <span class="tt">Literals_Section_Header</span> uses 1 byte. <span class="tt">Regenerated_Size = Literals_Section_Header[0]&gt;&gt;3</span></li>
<li><span class="tt">Size_Format</span> == 01 : <span class="tt">Size_Format</span> uses 2 bits. <span class="tt">Regenerated_Size</span> uses 12 bits (0-4095). <span class="tt">Literals_Section_Header</span> uses 2 bytes. <span class="tt">Regenerated_Size = (Literals_Section_Header[0]&gt;&gt;4) + (Literals_Section_Header[1]&lt;&lt;4)</span></li>
<li><span class="tt">Size_Format</span> == 11 : <span class="tt">Size_Format</span> uses 2 bits. <span class="tt">Regenerated_Size</span> uses 20 bits (0-1048575). <span class="tt">Literals_Section_Header</span> uses 3 bytes. <span class="tt">Regenerated_Size = (Literals_Section_Header[0]&gt;&gt;4) + (Literals_Section_Header[1]&lt;&lt;4) + (Literals_Section_Header[2]&lt;&lt;12)</span></li>
</ul>
<p>Only Stream1 is present for these cases. Note : it's allowed to represent a short value (for example <span class="tt">27</span>) using a long format, even if it's less efficient.</p>
<p><b><span class="tt">Size_Format</span> for <span class="tt">Compressed_Literals_Block</span> and <span class="tt">Treeless_Literals_Block</span></b> :</p>
<p><span class="tt">Size_Format</span> always uses 2 bits.</p>
<ul>
<li><span class="tt">Size_Format</span> == 00 : <em>A single stream</em>. Both <span class="tt">Regenerated_Size</span> and <span class="tt">Compressed_Size</span> use 10 bits (0-1023). <span class="tt">Literals_Section_Header</span> uses 3 bytes.</li>
<li><span class="tt">Size_Format</span> == 01 : 4 streams. Both <span class="tt">Regenerated_Size</span> and <span class="tt">Compressed_Size</span> use 10 bits (6-1023). <span class="tt">Literals_Section_Header</span> uses 3 bytes.</li>
<li><span class="tt">Size_Format</span> == 10 : 4 streams. Both <span class="tt">Regenerated_Size</span> and <span class="tt">Compressed_Size</span> use 14 bits (6-16383). <span class="tt">Literals_Section_Header</span> uses 4 bytes.</li>
<li><span class="tt">Size_Format</span> == 11 : 4 streams. Both <span class="tt">Regenerated_Size</span> and <span class="tt">Compressed_Size</span> use 18 bits (6-262143). <span class="tt">Literals_Section_Header</span> uses 5 bytes.</li>
</ul>
<p>Both <span class="tt">Compressed_Size</span> and <span class="tt">Regenerated_Size</span> fields follow <b>little-endian</b> convention. Note: <span class="tt">Compressed_Size</span> <b>includes</b> the size of the Huffman Tree description <em>when</em> it is present. Note 2: <span class="tt">Compressed_Size</span> can never be <span class="tt">==0</span>. Even in single-stream scenario, assuming an empty content, it must be <span class="tt">&gt;=1</span>, since it contains at least the final end bit flag. In 4-streams scenario, a valid <span class="tt">Compressed_Size</span> is necessarily <span class="tt">&gt;= 10</span> (6 bytes for the jump table, + 4x1 bytes for the 4 streams).</p>
<p>4 streams is faster than 1 stream in decompression speed, by exploiting instruction level parallelism. But it's also more expensive, costing on average ~7.3 bytes more than the 1 stream mode, mostly from the jump table.</p>
<p>In general, use the 4 streams mode when there are more literals to decode, to favor higher decompression speeds. Note that beyond &gt;1KB of literals, the 4 streams mode is compulsory.</p>
<p>Note that a minimum of 6 bytes is required for the 4 streams mode. That's a technical minimum, but it's not recommended to employ the 4 streams mode for such a small quantity, that would be wasteful. A more practical lower bound would be around ~256 bytes.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md106"></a>
Raw Literals Block</h3>
<p>The data in Stream1 is <span class="tt">Regenerated_Size</span> bytes long, it contains the raw literals data to be used during [Sequence Execution].</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md107"></a>
RLE Literals Block</h3>
<p>Stream1 consists of a single byte which should be repeated <span class="tt">Regenerated_Size</span> times to generate the decoded literals.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md108"></a>
Compressed Literals Block and Treeless Literals Block</h3>
<p>Both of these modes contain Huffman encoded data.</p>
<p>For <span class="tt">Treeless_Literals_Block</span>, the Huffman table comes from previously compressed literals block, or from a dictionary.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md109"></a>
<span class="tt">Huffman_Tree_Description</span></h2>
<p>This section is only present when <span class="tt">Literals_Block_Type</span> type is <span class="tt">Compressed_Literals_Block</span> (<span class="tt">2</span>). The tree describes the weights of all literals symbols that can be present in the literals block, at least 2 and up to 256. The format of the Huffman tree description can be found at Huffman Tree description. The size of <span class="tt">Huffman_Tree_Description</span> is determined during decoding process, it must be used to determine where streams begin. <span class="tt">Total_Streams_Size = Compressed_Size - Huffman_Tree_Description_Size</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md110"></a>
Jump Table</h2>
<p>The Jump Table is only present when there are 4 Huffman-coded streams.</p>
<p>Reminder : Huffman compressed data consists of either 1 or 4 streams.</p>
<p>If only one stream is present, it is a single bitstream occupying the entire remaining portion of the literals block, encoded as described in Huffman-Coded Streams.</p>
<p>If there are four streams, <span class="tt">Literals_Section_Header</span> only provided enough information to know the decompressed and compressed sizes of all four streams <em>combined</em>. The decompressed size of <em>each</em> stream is equal to <span class="tt">(Regenerated_Size+3)/4</span>, except for the last stream which may be up to 3 bytes smaller, to reach a total decompressed size as specified in <span class="tt">Regenerated_Size</span>.</p>
<p>The compressed size of each stream is provided explicitly in the Jump Table. Jump Table is 6 bytes long, and consists of three 2-byte <b>little-endian</b> fields, describing the compressed sizes of the first three streams. <span class="tt">Stream4_Size</span> is computed from <span class="tt">Total_Streams_Size</span> minus sizes of other streams:</p>
<p><span class="tt">Stream4_Size = Total_Streams_Size - 6 - Stream1_Size - Stream2_Size - Stream3_Size</span>.</p>
<p><span class="tt">Stream4_Size</span> is necessarily <span class="tt">&gt;= 1</span>. Therefore, if <span class="tt">Total_Streams_Size &lt; Stream1_Size + Stream2_Size + Stream3_Size + 6 + 1</span>, data is considered corrupted.</p>
<p>Each of these 4 bitstreams is then decoded independently as a Huffman-Coded stream, as described in Huffman-Coded Streams</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md111"></a>
Sequences Section</h1>
<p>A compressed block is a succession of <em>sequences</em> . A sequence is a literal copy command, followed by a match copy command. A literal copy command specifies a length. It is the number of bytes to be copied (or extracted) from the Literals Section. A match copy command specifies an offset and a length.</p>
<p>When all <em>sequences</em> are decoded, if there are literals left in the <em>literals section</em>, these bytes are added at the end of the block.</p>
<p>This is described in more detail in Sequence Execution.</p>
<p>The <span class="tt">Sequences_Section</span> regroup all symbols required to decode commands. There are 3 symbol types : literals lengths, offsets and match lengths. They are encoded together, interleaved, in a single <em>bitstream</em>.</p>
<p>The <span class="tt">Sequences_Section</span> starts by a header, followed by optional probability tables for each symbol type, followed by the bitstream.</p>
<p>| <span class="tt">Sequences_Section_Header</span> | [<span class="tt">Literals_Length_Table</span>] | [<span class="tt">Offset_Table</span>] | [<span class="tt">Match_Length_Table</span>] | bitStream | | -----------------------&mdash; | ----------------------&mdash; | -------------&mdash; | -------------------&mdash; | ------&mdash; |</p>
<p>To decode the <span class="tt">Sequences_Section</span>, it's required to know its size. Its size is deduced from the size of <span class="tt">Literals_Section</span>: <span class="tt">Sequences_Section_Size = Block_Size - Literals_Section_Size</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md112"></a>
<span class="tt">Sequences_Section_Header</span></h3>
<p>Consists of 2 items:</p><ul>
<li><span class="tt">Number_of_Sequences</span></li>
<li>Symbol compression modes</li>
</ul>
<p><b><span class="tt">Number_of_Sequences</span></b></p>
<p>This is a variable size field using between 1 and 3 bytes. Let's call its first byte <span class="tt">byte0</span>.</p><ul>
<li><span class="tt">if (byte0 &lt; 128)</span> : <span class="tt">Number_of_Sequences = byte0</span> . Uses 1 byte.</li>
<li><span class="tt">if (byte0 &lt; 255)</span> : <span class="tt">Number_of_Sequences = ((byte0 - 0x80) &lt;&lt; 8) + byte1</span>. Uses 2 bytes. Note that the 2 bytes format fully overlaps the 1 byte format.</li>
<li><span class="tt">if (byte0 == 255)</span>: <span class="tt">Number_of_Sequences = byte1 + (byte2&lt;&lt;8) + 0x7F00</span>. Uses 3 bytes.</li>
</ul>
<p><span class="tt">if (Number_of_Sequences == 0)</span> : there are no sequences. The sequence section stops immediately, FSE tables used in <span class="tt">Repeat_Mode</span> aren't updated. Block's decompressed content is defined solely by the Literals Section content.</p>
<p><b>Symbol compression modes</b></p>
<p>This is a single byte, defining the compression mode of each symbol type.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Bit number  </th><th class="markdownTableHeadNone">7-6  </th><th class="markdownTableHeadNone">5-4  </th><th class="markdownTableHeadNone">3-2  </th><th class="markdownTableHeadNone">1-0  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Field name  </td><td class="markdownTableBodyNone"><span class="tt">Literals_Lengths_Mode</span>  </td><td class="markdownTableBodyNone"><span class="tt">Offsets_Mode</span>  </td><td class="markdownTableBodyNone"><span class="tt">Match_Lengths_Mode</span>  </td><td class="markdownTableBodyNone"><span class="tt">Reserved</span>  </td></tr>
</table>
<p>The last field, <span class="tt">Reserved</span>, must be all-zeroes.</p>
<p><span class="tt">Literals_Lengths_Mode</span>, <span class="tt">Offsets_Mode</span> and <span class="tt">Match_Lengths_Mode</span> define the <span class="tt">Compression_Mode</span> of literals lengths, offsets, and match lengths symbols respectively.</p>
<p>They follow the same enumeration :</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value  </th><th class="markdownTableHeadNone">0  </th><th class="markdownTableHeadNone">1  </th><th class="markdownTableHeadNone">2  </th><th class="markdownTableHeadNone">3  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Compression_Mode</span>  </td><td class="markdownTableBodyNone"><span class="tt">Predefined_Mode</span>  </td><td class="markdownTableBodyNone"><span class="tt">RLE_Mode</span>  </td><td class="markdownTableBodyNone"><span class="tt">FSE_Compressed_Mode</span>  </td><td class="markdownTableBodyNone"><span class="tt">Repeat_Mode</span>  </td></tr>
</table>
<ul>
<li><span class="tt">Predefined_Mode</span> : A predefined FSE distribution table is used, defined in default distributions. No distribution table will be present.</li>
<li><span class="tt">RLE_Mode</span> : The table description consists of a single byte, which contains the symbol's value. This symbol will be used for all sequences.</li>
<li><span class="tt">FSE_Compressed_Mode</span> : standard FSE compression. A distribution table will be present. The format of this distribution table is described in FSE Table Description. Note that the maximum allowed accuracy log for literals length and match length tables is 9, and the maximum accuracy log for the offsets table is 8. <span class="tt">FSE_Compressed_Mode</span> must not be used when only one symbol is present, <span class="tt">RLE_Mode</span> should be used instead (although any other mode will work).</li>
<li><span class="tt">Repeat_Mode</span> : The table used in the previous <span class="tt">Compressed_Block</span> with <span class="tt">Number_of_Sequences &gt; 0</span> will be used again, or if this is the first block, table in the dictionary will be used. Note that this includes <span class="tt">RLE_mode</span>, so if <span class="tt">Repeat_Mode</span> follows <span class="tt">RLE_Mode</span>, the same symbol will be repeated. It also includes <span class="tt">Predefined_Mode</span>, in which case <span class="tt">Repeat_Mode</span> will have same outcome as <span class="tt">Predefined_Mode</span>. No distribution table will be present. If this mode is used without any previous sequence table in the frame (nor dictionary) to repeat, this should be treated as corruption.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md113"></a>
The codes for literals lengths, match lengths, and offsets.</h3>
<p>Each symbol is a <em>code</em> in its own context, which specifies <span class="tt">Baseline</span> and <span class="tt">Number_of_Bits</span> to add. <em>Codes</em> are FSE compressed, and interleaved with raw additional bits in the same bitstream.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md114"></a>
Literals length codes</h4>
<p>Literals length codes are values ranging from <span class="tt">0</span> to <span class="tt">35</span> included. They define lengths from 0 to 131071 bytes. The literals length is equal to the decoded <span class="tt">Baseline</span> plus the result of reading <span class="tt">Number_of_Bits</span> bits from the bitstream, as a <b>little-endian</b> value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Literals_Length_Code</span>  </th><th class="markdownTableHeadNone">0-15  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">length  </td><td class="markdownTableBodyNone"><span class="tt">Literals_Length_Code</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">0  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Literals_Length_Code</span>  </th><th class="markdownTableHeadNone">16  </th><th class="markdownTableHeadNone">17  </th><th class="markdownTableHeadNone">18  </th><th class="markdownTableHeadNone">19  </th><th class="markdownTableHeadNone">20  </th><th class="markdownTableHeadNone">21  </th><th class="markdownTableHeadNone">22  </th><th class="markdownTableHeadNone">23  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Baseline</span>  </td><td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">28  </td><td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">40  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">3  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Literals_Length_Code</span>  </th><th class="markdownTableHeadNone">24  </th><th class="markdownTableHeadNone">25  </th><th class="markdownTableHeadNone">26  </th><th class="markdownTableHeadNone">27  </th><th class="markdownTableHeadNone">28  </th><th class="markdownTableHeadNone">29  </th><th class="markdownTableHeadNone">30  </th><th class="markdownTableHeadNone">31  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Baseline</span>  </td><td class="markdownTableBodyNone">48  </td><td class="markdownTableBodyNone">64  </td><td class="markdownTableBodyNone">128  </td><td class="markdownTableBodyNone">256  </td><td class="markdownTableBodyNone">512  </td><td class="markdownTableBodyNone">1024  </td><td class="markdownTableBodyNone">2048  </td><td class="markdownTableBodyNone">4096  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">12  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Literals_Length_Code</span>  </th><th class="markdownTableHeadNone">32  </th><th class="markdownTableHeadNone">33  </th><th class="markdownTableHeadNone">34  </th><th class="markdownTableHeadNone">35  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Baseline</span>  </td><td class="markdownTableBodyNone">8192  </td><td class="markdownTableBodyNone">16384  </td><td class="markdownTableBodyNone">32768  </td><td class="markdownTableBodyNone">65536  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">16  </td></tr>
</table>
<h4 class="doxsection"><a class="anchor" id="autotoc_md115"></a>
Match length codes</h4>
<p>Match length codes are values ranging from <span class="tt">0</span> to <span class="tt">52</span> included. They define lengths from 3 to 131074 bytes. The match length is equal to the decoded <span class="tt">Baseline</span> plus the result of reading <span class="tt">Number_of_Bits</span> bits from the bitstream, as a <b>little-endian</b> value.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Match_Length_Code</span>  </th><th class="markdownTableHeadNone">0-31  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">value  </td><td class="markdownTableBodyNone"><span class="tt">Match_Length_Code</span> + 3  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">0  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Match_Length_Code</span>  </th><th class="markdownTableHeadNone">32  </th><th class="markdownTableHeadNone">33  </th><th class="markdownTableHeadNone">34  </th><th class="markdownTableHeadNone">35  </th><th class="markdownTableHeadNone">36  </th><th class="markdownTableHeadNone">37  </th><th class="markdownTableHeadNone">38  </th><th class="markdownTableHeadNone">39  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Baseline</span>  </td><td class="markdownTableBodyNone">35  </td><td class="markdownTableBodyNone">37  </td><td class="markdownTableBodyNone">39  </td><td class="markdownTableBodyNone">41  </td><td class="markdownTableBodyNone">43  </td><td class="markdownTableBodyNone">47  </td><td class="markdownTableBodyNone">51  </td><td class="markdownTableBodyNone">59  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">3  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Match_Length_Code</span>  </th><th class="markdownTableHeadNone">40  </th><th class="markdownTableHeadNone">41  </th><th class="markdownTableHeadNone">42  </th><th class="markdownTableHeadNone">43  </th><th class="markdownTableHeadNone">44  </th><th class="markdownTableHeadNone">45  </th><th class="markdownTableHeadNone">46  </th><th class="markdownTableHeadNone">47  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Baseline</span>  </td><td class="markdownTableBodyNone">67  </td><td class="markdownTableBodyNone">83  </td><td class="markdownTableBodyNone">99  </td><td class="markdownTableBodyNone">131  </td><td class="markdownTableBodyNone">259  </td><td class="markdownTableBodyNone">515  </td><td class="markdownTableBodyNone">1027  </td><td class="markdownTableBodyNone">2051  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">11  </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><span class="tt">Match_Length_Code</span>  </th><th class="markdownTableHeadNone">48  </th><th class="markdownTableHeadNone">49  </th><th class="markdownTableHeadNone">50  </th><th class="markdownTableHeadNone">51  </th><th class="markdownTableHeadNone">52  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Baseline</span>  </td><td class="markdownTableBodyNone">4099  </td><td class="markdownTableBodyNone">8195  </td><td class="markdownTableBodyNone">16387  </td><td class="markdownTableBodyNone">32771  </td><td class="markdownTableBodyNone">65539  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">16  </td></tr>
</table>
<h4 class="doxsection"><a class="anchor" id="autotoc_md116"></a>
Offset codes</h4>
<p>Offset codes are values ranging from <span class="tt">0</span> to <span class="tt">N</span>.</p>
<p>A decoder is free to limit its maximum <span class="tt">N</span> supported. Recommendation is to support at least up to <span class="tt">22</span>. For information, at the time of this writing. the reference decoder supports a maximum <span class="tt">N</span> value of <span class="tt">31</span>.</p>
<p>An offset code is also the number of additional bits to read in <b>little-endian</b> fashion, and can be translated into an <span class="tt">Offset_Value</span> using the following formulas :</p>
<div class="fragment"><div class="line">Offset_Value = (1 &lt;&lt; offsetCode) + readNBits(offsetCode);</div>
<div class="line">if (Offset_Value &gt; 3) offset = Offset_Value - 3;</div>
</div><!-- fragment --><p> It means that maximum <span class="tt">Offset_Value</span> is <span class="tt">(2^(N+1))-1</span> supporting back-reference distances up to <span class="tt">(2^(N+1))-4</span>, but is limited by maximum back-reference distance.</p>
<p><span class="tt">Offset_Value</span> from 1 to 3 are special : they define "repeat codes". This is described in more detail in Repeat Offsets.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md117"></a>
Decoding Sequences</h3>
<p>FSE bitstreams are read in reverse direction than written. In zstd, the compressor writes bits forward into a block and the decompressor must read the bitstream <em>backwards</em>.</p>
<p>To find the start of the bitstream it is therefore necessary to know the offset of the last byte of the block which can be found by counting <span class="tt">Block_Size</span> bytes after the block header.</p>
<p>After writing the last bit containing information, the compressor writes a single <span class="tt">1</span>-bit and then fills the byte with 0-7 <span class="tt">0</span> bits of padding. The last byte of the compressed bitstream cannot be <span class="tt">0</span> for that reason.</p>
<p>When decompressing, the last byte containing the padding is the first byte to read. The decompressor needs to skip 0-7 initial <span class="tt">0</span>-bits and the first <span class="tt">1</span>-bit it occurs. Afterwards, the useful part of the bitstream begins.</p>
<p>FSE decoding requires a 'state' to be carried from symbol to symbol. For more explanation on FSE decoding, see the FSE section.</p>
<p>For sequence decoding, a separate state keeps track of each literal lengths, offsets, and match lengths symbols. Some FSE primitives are also used. For more details on the operation of these primitives, see the FSE section.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md118"></a>
Starting states</h4>
<p>The bitstream starts with initial FSE state values, each using the required number of bits in their respective <em>accuracy</em>, decoded previously from their normalized distribution.</p>
<p>It starts by <span class="tt">Literals_Length_State</span>, followed by <span class="tt">Offset_State</span>, and finally <span class="tt">Match_Length_State</span>.</p>
<p>Reminder : always keep in mind that all values are read <em>backward</em>, so the 'start' of the bitstream is at the highest position in memory, immediately before the last <span class="tt">1</span>-bit for padding.</p>
<p>After decoding the starting states, a single sequence is decoded <span class="tt">Number_Of_Sequences</span> times. These sequences are decoded in order from first to last. Since the compressor writes the bitstream in the forward direction, this means the compressor must encode the sequences starting with the last one and ending with the first.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md119"></a>
Decoding a sequence</h4>
<p>For each of the symbol types, the FSE state can be used to determine the appropriate code. The code then defines the <span class="tt">Baseline</span> and <span class="tt">Number_of_Bits</span> to read for each type. See the description of the codes for how to determine these values.</p>
<p>Decoding starts by reading the <span class="tt">Number_of_Bits</span> required to decode <span class="tt">Offset</span>. It then does the same for <span class="tt">Match_Length</span>, and then for <span class="tt">Literals_Length</span>. This sequence is then used for sequence execution.</p>
<p>If it is not the last sequence in the block, the next operation is to update states. Using the rules pre-calculated in the decoding tables, <span class="tt">Literals_Length_State</span> is updated, followed by <span class="tt">Match_Length_State</span>, and then <span class="tt">Offset_State</span>. See the FSE section for details on how to update states from the bitstream.</p>
<p>This operation will be repeated <span class="tt">Number_of_Sequences</span> times. At the end, the bitstream shall be entirely consumed, otherwise the bitstream is considered corrupted.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md120"></a>
Default Distributions</h3>
<p>If <span class="tt">Predefined_Mode</span> is selected for a symbol type, its FSE decoding table is generated from a predefined distribution table defined here. For details on how to convert this distribution into a decoding table, see the FSE section.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md121"></a>
Literals Length</h4>
<p>The decoding table uses an accuracy log of 6 bits (64 states). </p><div class="fragment"><div class="line">short literalsLength_defaultDistribution[36] =</div>
<div class="line">        { 4, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1,</div>
<div class="line">          2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 1, 1, 1, 1, 1,</div>
<div class="line">         -1,-1,-1,-1 };</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md122"></a>
Match Length</h4>
<p>The decoding table uses an accuracy log of 6 bits (64 states). </p><div class="fragment"><div class="line">short matchLengths_defaultDistribution[53] =</div>
<div class="line">        { 1, 4, 3, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,</div>
<div class="line">          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,</div>
<div class="line">          1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,-1,-1,</div>
<div class="line">         -1,-1,-1,-1,-1 };</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md123"></a>
Offset Codes</h4>
<p>The decoding table uses an accuracy log of 5 bits (32 states), and supports a maximum <span class="tt">N</span> value of 28, allowing offset values up to 536,870,908 .</p>
<p>If any sequence in the compressed block requires a larger offset than this, it's not possible to use the default distribution to represent it. </p><div class="fragment"><div class="line">short offsetCodes_defaultDistribution[29] =</div>
<div class="line">        { 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1,</div>
<div class="line">          1, 1, 1, 1, 1, 1, 1, 1,-1,-1,-1,-1,-1 };</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md124"></a>
Sequence Execution</h1>
<p>Once literals and sequences have been decoded, they are combined to produce the decoded content of a block.</p>
<p>Each sequence consists of a tuple of (<span class="tt">literals_length</span>, <span class="tt">offset_value</span>, <span class="tt">match_length</span>), decoded as described in the Sequences Section. To execute a sequence, first copy <span class="tt">literals_length</span> bytes from the decoded literals to the output.</p>
<p>Then <span class="tt">match_length</span> bytes are copied from previous decoded data. The offset to copy from is determined by <span class="tt">offset_value</span>: if <span class="tt">offset_value &gt; 3</span>, then the offset is <span class="tt">offset_value - 3</span>. If <span class="tt">offset_value</span> is from 1-3, the offset is a special repeat offset value. See the repeat offset section for how the offset is determined in this case.</p>
<p>The offset is defined as from the current position, so an offset of 6 and a match length of 3 means that 3 bytes should be copied from 6 bytes back. Note that all offsets leading to previously decoded data must be smaller than <span class="tt">Window_Size</span> defined in <span class="tt">Frame_Header_Descriptor</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md125"></a>
Repeat offsets</h3>
<p>As seen in Sequence Execution, the first 3 values define a repeated offset and we will call them <span class="tt">Repeated_Offset1</span>, <span class="tt">Repeated_Offset2</span>, and <span class="tt">Repeated_Offset3</span>. They are sorted in recency order, with <span class="tt">Repeated_Offset1</span> meaning "most recent one".</p>
<p>If <span class="tt">offset_value == 1</span>, then the offset used is <span class="tt">Repeated_Offset1</span>, etc.</p>
<p>There is an exception though, when current sequence's <span class="tt">literals_length = 0</span>. In this case, repeated offsets are shifted by one, so an <span class="tt">offset_value</span> of 1 means <span class="tt">Repeated_Offset2</span>, an <span class="tt">offset_value</span> of 2 means <span class="tt">Repeated_Offset3</span>, and an <span class="tt">offset_value</span> of 3 means <span class="tt">Repeated_Offset1 - 1</span>.</p>
<p>In the final case, if <span class="tt">Repeated_Offset1 - 1</span> evaluates to 0, then the data is considered corrupted.</p>
<p>For the first block, the starting offset history is populated with following values : <span class="tt">Repeated_Offset1</span>=1, <span class="tt">Repeated_Offset2</span>=4, <span class="tt">Repeated_Offset3</span>=8, unless a dictionary is used, in which case they come from the dictionary.</p>
<p>Then each block gets its starting offset history from the ending values of the most recent <span class="tt">Compressed_Block</span>. Note that blocks which are not <span class="tt">Compressed_Block</span> are skipped, they do not contribute to offset history.</p>
<h5 class="doxsection"><a class="anchor" id="autotoc_md126"></a>
Offset updates rules</h5>
<p>During the execution of the sequences of a <span class="tt">Compressed_Block</span>, the <span class="tt">Repeated_Offsets</span>' values are kept up to date, so that they always represent the three most-recently used offsets. In order to achieve that, they are updated after executing each sequence in the following way:</p>
<p>When the sequence's <span class="tt">offset_value</span> does not refer to one of the <span class="tt">Repeated_Offsets</span>&ndash;when it has value greater than 3, or when it has value 3 and the sequence's <span class="tt">literals_length</span> is zero&ndash;the <span class="tt">Repeated_Offsets</span>' values are shifted back one, and <span class="tt">Repeated_Offset1</span> takes on the value of the just-used offset.</p>
<p>Otherwise, when the sequence's <span class="tt">offset_value</span> refers to one of the <span class="tt">Repeated_Offsets</span>&ndash;when it has value 1 or 2, or when it has value 3 and the sequence's <span class="tt">literals_length</span> is non-zero&ndash;the <span class="tt">Repeated_Offsets</span> are re-ordered so that <span class="tt">Repeated_Offset1</span> takes on the value of the used Repeated_Offset, and the existing values are pushed back from the first <span class="tt">Repeated_Offset</span> through to the <span class="tt">Repeated_Offset</span> selected by the <span class="tt">offset_value</span>. This effectively performs a single-stepped wrapping rotation of the values of these offsets, so that their order again reflects the recency of their use.</p>
<p>The following table shows the values of the <span class="tt">Repeated_Offsets</span> as a series of sequences are applied to them:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><span class="tt">offset_value</span>  </th><th class="markdownTableHeadCenter"><span class="tt">literals_length</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Repeated_Offset1</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Repeated_Offset2</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Repeated_Offset3</span>  </th><th class="markdownTableHeadCenter">Comment  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">8  </td><td class="markdownTableBodyCenter">starting values  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1114  </td><td class="markdownTableBodyCenter">11  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">non-repeat  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">22  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">repeat 1: no change  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">2225  </td><td class="markdownTableBodyCenter">22  </td><td class="markdownTableBodyCenter">2222  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">non-repeat  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">1114  </td><td class="markdownTableBodyCenter">111  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">2222  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">non-repeat  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3336  </td><td class="markdownTableBodyCenter">33  </td><td class="markdownTableBodyCenter">3333  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">2222  </td><td class="markdownTableBodyCenter">non-repeat  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2  </td><td class="markdownTableBodyCenter">22  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">3333  </td><td class="markdownTableBodyCenter">2222  </td><td class="markdownTableBodyCenter">repeat 2: swap 1 &amp; 2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">33  </td><td class="markdownTableBodyCenter">2222  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">3333  </td><td class="markdownTableBodyCenter">repeat 3: rotate 3 to 1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2221  </td><td class="markdownTableBodyCenter">2222  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">special case : insert <span class="tt">repeat1 - 1</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2222  </td><td class="markdownTableBodyCenter">2221  </td><td class="markdownTableBodyCenter">1111  </td><td class="markdownTableBodyCenter">== repeat 2  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="autotoc_md127"></a>
Skippable Frames</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><span class="tt">Magic_Number</span>  </th><th class="markdownTableHeadCenter"><span class="tt">Frame_Size</span>  </th><th class="markdownTableHeadCenter"><span class="tt">User_Data</span>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">4 bytes  </td><td class="markdownTableBodyCenter">4 bytes  </td><td class="markdownTableBodyCenter">n bytes  </td></tr>
</table>
<p>Skippable frames allow the insertion of user-defined metadata into a flow of concatenated frames.</p>
<p>Skippable frames defined in this specification are compatible with <a href="https://lz4.github.io/lz4/">LZ4</a> ones.</p>
<p>From a compliant decoder perspective, skippable frames need just be skipped, and their content ignored, resuming decoding after the skippable frame.</p>
<p>It can be noted that a skippable frame can be used to watermark a stream of concatenated frames embedding any kind of tracking information (even just a UUID). Users wary of such possibility should scan the stream of concatenated frames in an attempt to detect such frame for analysis or removal.</p>
<p><b><span class="tt">Magic_Number</span></b></p>
<p>4 Bytes, <b>little-endian</b> format. Value : 0x184D2A5?, which means any value from 0x184D2A50 to 0x184D2A5F. All 16 values are valid to identify a skippable frame. This specification doesn't detail any specific tagging for skippable frames.</p>
<p><b><span class="tt">Frame_Size</span></b></p>
<p>This is the size, in bytes, of the following <span class="tt">User_Data</span> (without including the magic number nor the size field itself). This field is represented using 4 Bytes, <b>little-endian</b> format, unsigned 32-bits. This means <span class="tt">User_Data</span> can’t be bigger than (2^32-1) bytes.</p>
<p><b><span class="tt">User_Data</span></b></p>
<p>The <span class="tt">User_Data</span> can be anything. Data will just be skipped by the decoder.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md128"></a>
Entropy Encoding</h1>
<p>Two types of entropy encoding are used by the Zstandard format: FSE, and Huffman coding. Huffman is used to compress literals, while FSE is used for all other symbols (<span class="tt">Literals_Length_Code</span>, <span class="tt">Match_Length_Code</span>, offset codes) and to compress Huffman headers.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md129"></a>
FSE</h1>
<p>FSE, short for Finite State Entropy, is an entropy codec based on <a href="https://en.wikipedia.org/wiki/Asymmetric_Numeral_Systems">ANS</a>. FSE encoding/decoding involves a state that is carried over between symbols. Decoding must be done in the opposite direction as encoding. Therefore, all FSE bitstreams are read from end to beginning. Note that the order of the bits in the stream is not reversed, we just read each multi-bits element in the reverse order they are encoded.</p>
<p>For additional details on FSE, see <a href="https://github.com/Cyan4973/FiniteStateEntropy/">Finite State Entropy</a>.</p>
<p>FSE decoding is directed by a decoding table with a power of 2 size, each row containing three elements: <span class="tt">Symbol</span>, <span class="tt">Num_Bits</span>, and <span class="tt">Baseline</span>. The <span class="tt">log2</span> of the table size is its <span class="tt">Accuracy_Log</span>. An FSE state value represents an index in this table.</p>
<p>To obtain the initial state value, consume <span class="tt">Accuracy_Log</span> bits from the stream as a <b>little-endian</b> value. The first symbol in the stream is the <span class="tt">Symbol</span> indicated in the table for that state. To obtain the next state value, the decoder should consume <span class="tt">Num_Bits</span> bits from the stream as a <b>little-endian</b> value and add it to <span class="tt">Baseline</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md130"></a>
FSE Table Description</h2>
<p>To decode an FSE bitstream, it is necessary to build its FSE decoding table. The decoding table is derived from a distribution of Probabilities. The Zstandard format encodes distributions of Probabilities as follows:</p>
<p>The distribution of probabilities is described in a bitstream which is read forward, in <b>little-endian</b> fashion. The amount of bytes consumed from the bitstream to describe the distribution is discovered at the end of the decoding process.</p>
<p>The bitstream starts by reporting on which scale the distribution operates. Let's <span class="tt">low4Bits</span> designate the lowest 4 bits of the first byte : <span class="tt">Accuracy_Log = low4bits + 5</span>.</p>
<p>An FSE distribution table describes the probabilities of all symbols from <span class="tt">0</span> to the last present one (included) in natural order. The sum of probabilities is normalized to reach a power of 2 total of <span class="tt">1 &lt;&lt; Accuracy_Log</span> . There must be two or more symbols with non-zero probabilities.</p>
<p>The number of bits used to decode each probability is variable. It depends on :</p>
<ul>
<li>Remaining probabilities + 1 : <b>example</b> : Presuming an <span class="tt">Accuracy_Log</span> of 8, and presuming 100 probability points have already been distributed, the decoder may read any value from <span class="tt">0</span> to <span class="tt">256 - 100 + 1 == 157</span> (inclusive). Therefore, it may read up to <span class="tt">log2sup(157) == 8</span> bits, where <span class="tt">log2sup(N)</span> is the smallest integer <span class="tt">T</span> that satisfies <span class="tt">(1 &lt;&lt; T) &gt; N</span>.</li>
<li>Value decoded : small values use 1 less bit : <b>example</b> : Presuming values from 0 to 157 (inclusive) are possible, 255-157 = 98 values are remaining in an 8-bits field. They are used this way : first 98 values (hence from 0 to 97) use only 7 bits, values from 98 to 157 use 8 bits. This is achieved through this scheme :</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">8-bit field read  </th><th class="markdownTableHeadNone">Value decoded  </th><th class="markdownTableHeadNone">Nb of bits consumed  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0 - 97  </td><td class="markdownTableBodyNone">0 - 97  </td><td class="markdownTableBodyNone">7  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">98 - 127  </td><td class="markdownTableBodyNone">98 - 127  </td><td class="markdownTableBodyNone">8  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">128 - 225  </td><td class="markdownTableBodyNone">0 - 97  </td><td class="markdownTableBodyNone">7  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">226 - 255  </td><td class="markdownTableBodyNone">128 - 157  </td><td class="markdownTableBodyNone">8  </td></tr>
</table>
<p>Probability is derived from Value decoded using the following formula: <span class="tt">Probality = Value - 1</span></p>
<p>Consequently, a Probability of <span class="tt">0</span> is described by a Value <span class="tt">1</span>.</p>
<p>A Value <span class="tt">0</span> is used to signal a special case, named "Probability `-1`". It describes a probability which should have been "less than 1". Its effect on the decoding table building process is described in the next section. For the purpose of counting total allocated probability points, it counts as one.</p>
<p>Symbols probabilities are read one by one, in order. After each probability is decoded, the total nb of probability points is updated. This is used to determine how many bits must be read to decode the probability of next symbol.</p>
<p>When a symbol has a <b>probability</b> of <span class="tt">zero</span> (decoded from reading a Value <span class="tt">1</span>), it is followed by a 2-bits repeat flag. This repeat flag tells how many probabilities of zeroes follow the current one. It provides a number ranging from 0 to 3. If it is a 3, another 2-bits repeat flag follows, and so on.</p>
<p>When the Probability for a symbol makes cumulated total reach <span class="tt">1 &lt;&lt; Accuracy_Log</span>, then it's the last symbol, and decoding is complete.</p>
<p>Then the decoder can tell how many bytes were used in this process, and how many symbols are present. The bitstream consumes a round number of bytes. Any remaining bit within the last byte is just unused.</p>
<p>If this process results in a non-zero probability for a symbol outside of the valid range of symbols that the FSE table is defined for, even if that symbol is not used, then the data is considered corrupted. For the specific case of offset codes, a decoder implementation may reject a frame containing a non-zero probability for an offset code larger than the largest offset code supported by the decoder implementation.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md131"></a>
From normalized distribution to decoding tables</h3>
<p>The normalized distribution of probabilities is enough to create a unique decoding table. It is generated using the following build rule :</p>
<p>The table has a size of <span class="tt">Table_Size = 1 &lt;&lt; Accuracy_Log</span>. Each row specifies the decoded symbol, and instructions to reach the next state (<span class="tt">Number_of_Bits</span> and <span class="tt">Baseline</span>).</p>
<p>Symbols are first scanned in their natural order for "less than 1" probabilities (previously decoded from a Value of <span class="tt">0</span>). Symbols with this special probability are being attributed a single row, starting from the end of the table and retreating. These symbols define a full state reset, reading <span class="tt">Accuracy_Log</span> bits.</p>
<p>Then, all remaining symbols, sorted in natural order, are allocated rows. Starting from smallest present symbol, and table position <span class="tt">0</span>, each symbol gets allocated as many rows as its probability.</p>
<p>Row allocation is not linear, it follows this order, in modular arithmetic: </p><div class="fragment"><div class="line">position += (tableSize&gt;&gt;1) + (tableSize&gt;&gt;3) + 3;</div>
<div class="line">position &amp;= tableSize-1;</div>
</div><!-- fragment --><p>Using above ordering rule, each symbol gets allocated as many rows as its probability. If a position is already occupied by a "less than 1" probability symbol, it is simply skipped, and the next position is allocated instead. Once enough rows have been allocated for the current symbol, the allocation process continues, using the next symbol, in natural order. This process guarantees that the table is entirely and exactly filled.</p>
<p>Each row specifies a decoded symbol, and is accessed by current state value. It also specifies <span class="tt">Number_of_Bits</span> and <span class="tt">Baseline</span>, which are required to determine next state value.</p>
<p>To correctly set these fields, it's necessary to sort all occurrences of each symbol in state value order, and then attribute N+1 bits to lower rows, and N bits to higher rows, following the process described below (using an example):</p>
<p><b>Example</b> : Presuming an <span class="tt">Accuracy_Log</span> of 7, let's imagine a symbol with a Probability of 5: it receives 5 rows, corresponding to 5 state values between <span class="tt">0</span> and <span class="tt">127</span>.</p>
<p>In this example, the first state value happens to be <span class="tt">1</span> (after unspecified previous symbols). The next 4 states are then determined using above modular arithmetic rule, which specifies to add <span class="tt">64+16+3 = 83</span> modulo <span class="tt">128</span> to jump to next position, producing the following series: <span class="tt">1</span>, <span class="tt">84</span>, <span class="tt">39</span>, <span class="tt">122</span>, <span class="tt">77</span> (modular arithmetic). (note: the next symbol will then start at <span class="tt">32</span>).</p>
<p>These state values are then sorted in natural order, resulting in the following series: <span class="tt">1</span>, <span class="tt">39</span>, <span class="tt">77</span>, <span class="tt">84</span>, <span class="tt">122</span>.</p>
<p>The next power of 2 after 5 is 8. Therefore, the probability space will be divided into 8 equal parts. Since the probability space is <span class="tt">1&lt;&lt;7 = 128</span> large, each share is <span class="tt">128/8 = 16</span> large.</p>
<p>In order to reach 8 shares, the <span class="tt">8-5 = 3</span> lowest states will count "double", doubling their shares (32 in width), hence requiring one more bit.</p>
<p>Baseline is assigned starting from the lowest state using fewer bits, continuing in natural state order, looping back at the beginning. Each state takes its allocated range from Baseline, sized by its <span class="tt">Number_of_Bits</span>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">state order  </th><th class="markdownTableHeadNone">0  </th><th class="markdownTableHeadNone">1  </th><th class="markdownTableHeadNone">2  </th><th class="markdownTableHeadNone">3  </th><th class="markdownTableHeadNone">4  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">state value  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">39  </td><td class="markdownTableBodyNone">77  </td><td class="markdownTableBodyNone">84  </td><td class="markdownTableBodyNone">122  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">width  </td><td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">4  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">allocation order  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">2  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Baseline</span>  </td><td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">64  </td><td class="markdownTableBodyNone">96  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">range  </td><td class="markdownTableBodyNone">32-63  </td><td class="markdownTableBodyNone">64-95  </td><td class="markdownTableBodyNone">96-127  </td><td class="markdownTableBodyNone">0-15  </td><td class="markdownTableBodyNone">16-31  </td></tr>
</table>
<p>During decoding, the next state value is determined by using current state value as row number, then reading the required <span class="tt">Number_of_Bits</span> from the bitstream, and adding the specified <span class="tt">Baseline</span>.</p>
<p>Note: as a trivial example, it follows that, for a symbol with a Probability of <span class="tt">1</span>, <span class="tt">Baseline</span> is necessarily <span class="tt">0</span>, and <span class="tt">Number_of_Bits</span> is necessarily <span class="tt">Accuracy_Log</span>.</p>
<p>See Appendix A to see the outcome of this process applied to the default distributions.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md132"></a>
Huffman Coding</h1>
<p>Zstandard Huffman-coded streams are read backwards, similar to the FSE bitstreams. Therefore, to find the start of the bitstream, it is required to know the offset of the last byte of the Huffman-coded stream.</p>
<p>After writing the last bit containing information, the compressor writes a single <span class="tt">1</span>-bit and then fills the byte with 0-7 <span class="tt">0</span> bits of padding. The last byte of the compressed bitstream cannot be <span class="tt">0</span> for that reason.</p>
<p>When decompressing, the last byte containing the padding is the first byte to read. The decompressor needs to skip 0-7 initial <span class="tt">0</span>-bits and the first <span class="tt">1</span>-bit it occurs. Afterwards, the useful part of the bitstream begins.</p>
<p>The bitstream contains Huffman-coded symbols in <b>little-endian</b> order, with the codes defined by the method below.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md133"></a>
Huffman Tree Description</h2>
<p>Prefix coding represents symbols from an a priori known alphabet by bit sequences (codewords), one codeword for each symbol, in a manner such that different symbols may be represented by bit sequences of different lengths, but a parser can always parse an encoded string unambiguously symbol-by-symbol.</p>
<p>Given an alphabet with known symbol frequencies, the Huffman algorithm allows the construction of an optimal prefix code using the fewest bits of any possible prefix codes for that alphabet.</p>
<p>Prefix code must not exceed a maximum code length. More bits improve accuracy but cost more header size, and require more memory or more complex decoding operations. This specification limits maximum code length to 11 bits.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md134"></a>
Representation</h3>
<p>All literal symbols from zero (included) to last present one (excluded) are represented by <span class="tt">Weight</span> with values from <span class="tt">0</span> to <span class="tt">Max_Number_of_Bits</span>. Transformation from <span class="tt">Weight</span> to <span class="tt">Number_of_Bits</span> follows this formula : </p><div class="fragment"><div class="line">Number_of_Bits = Weight ? (Max_Number_of_Bits + 1 - Weight) : 0</div>
</div><!-- fragment --><p> When a literal symbol is not present, it receives a <span class="tt">Weight</span> of 0. The least frequent symbol receives a <span class="tt">Weight</span> of 1. If no literal has a <span class="tt">Weight</span> of 1, then the data is considered corrupted. If there are not at least two literals with non-zero <span class="tt">Weight</span>, then the data is considered corrupted. The most frequent symbol receives a <span class="tt">Weight</span> anywhere between 1 and 11 (max). The last symbol's <span class="tt">Weight</span> is deduced from previously retrieved Weights, by completing to the nearest power of 2. It's necessarily non 0. If it's not possible to reach a clean power of 2 with a single <span class="tt">Weight</span> value, the Huffman Tree Description is considered invalid. This final power of 2 gives <span class="tt">Max_Number_of_Bits</span>, the depth of the current tree. <span class="tt">Max_Number_of_Bits</span> must be &lt;= 11, otherwise the representation is considered corrupted.</p>
<p><b>Example</b> : Let's presume the following Huffman tree must be described :</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">literal symbol  </th><th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">B  </th><th class="markdownTableHeadNone">C  </th><th class="markdownTableHeadNone">D  </th><th class="markdownTableHeadNone">E  </th><th class="markdownTableHeadNone">F  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">4  </td></tr>
</table>
<p>The tree depth is 4, since its longest elements uses 4 bits (longest elements are the ones with smallest frequency).</p>
<p>All symbols will now receive a <span class="tt">Weight</span> instead of <span class="tt">Number_of_Bits</span>. Weight formula is : </p><div class="fragment"><div class="line">Weight = Number_of_Bits ? (Max_Number_of_Bits + 1 - Number_of_Bits) : 0</div>
</div><!-- fragment --><p> It gives the following series of Weights :</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">literal symbol  </th><th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">B  </th><th class="markdownTableHeadNone">C  </th><th class="markdownTableHeadNone">D  </th><th class="markdownTableHeadNone">E  </th><th class="markdownTableHeadNone">F  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Weight</span>  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td></tr>
</table>
<p>This list will be sent to the decoder, with the following modifications:</p>
<ul>
<li><span class="tt">F</span> will not be listed, because it can be determined from previous symbols</li>
<li>nor will symbols above <span class="tt">F</span> as they are all 0</li>
<li>on the other hand, all symbols before <span class="tt">A</span>, starting with <span class="tt">\0</span>, will be listed, with a Weight of 0.</li>
</ul>
<p>The decoder will do the inverse operation : having collected weights of literal symbols from <span class="tt">A</span> to <span class="tt">E</span>, it knows the last literal, <span class="tt">F</span>, is present with a non-zero <span class="tt">Weight</span>. The <span class="tt">Weight</span> of <span class="tt">F</span> can be determined by advancing to the next power of 2. The sum of <span class="tt">2^(Weight-1)</span> (excluding 0's) is : <span class="tt">8 + 4 + 2 + 0 + 1 = 15</span>. Nearest larger power of 2 value is 16. Therefore, <span class="tt">Max_Number_of_Bits = log2(16) = 4</span> and <span class="tt">Weight[F] = log_2(16 - 15) + 1 = 1</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md135"></a>
Huffman Tree header</h3>
<p>This is a single byte value (0-255), which describes how the series of weights is encoded.</p>
<ul>
<li>if <span class="tt">headerByte</span> &lt; 128 : the series of weights is compressed using FSE (see below). The length of the FSE-compressed series is equal to <span class="tt">headerByte</span> (0-127).</li>
<li>if <span class="tt">headerByte</span> &gt;= 128 :<ul>
<li>the series of weights uses a direct representation, where each <span class="tt">Weight</span> is encoded directly as a 4 bits field (0-15).</li>
<li>They are encoded forward, 2 weights to a byte, first weight taking the top four bits and second one taking the bottom four.<ul>
<li>e.g. the following operations could be used to read the weights: <span class="tt">Weight[0] = (Byte[0] &gt;&gt; 4), Weight[1] = (Byte[0] &amp; 0xf)</span>, etc.</li>
</ul>
</li>
<li>The full representation occupies <span class="tt">Ceiling(Number_of_Weights/2)</span> bytes, meaning it uses only full bytes even if <span class="tt">Number_of_Weights</span> is odd.</li>
<li><span class="tt">Number_of_Weights = headerByte - 127</span>.<ul>
<li>Note that maximum <span class="tt">Number_of_Weights</span> is 255-127 = 128, therefore, only up to 128 <span class="tt">Weight</span> can be encoded using direct representation.</li>
<li>Since the last non-zero <span class="tt">Weight</span> is <em>not</em> encoded, this scheme is compatible with alphabet sizes of up to 129 symbols, hence including literal symbol 128.</li>
<li>If any literal symbol &gt; 128 has a non-zero <span class="tt">Weight</span>, direct representation is not possible. In such case, it's necessary to use FSE compression.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md136"></a>
Finite State Entropy (FSE) compression of Huffman weights</h3>
<p>In this case, the series of Huffman weights is compressed using FSE compression. It's a single bitstream with 2 interleaved states, sharing a single distribution table.</p>
<p>To decode an FSE bitstream, it is necessary to know its compressed size. Compressed size is provided by <span class="tt">headerByte</span>. It's also necessary to know its <em>maximum possible</em> decompressed size, which is <span class="tt">255</span>, since literal symbols span from <span class="tt">0</span> to <span class="tt">255</span>, and last symbol's <span class="tt">Weight</span> is not represented.</p>
<p>An FSE bitstream starts by a header, describing probabilities distribution. It will create a Decoding Table. For a list of Huffman weights, the maximum accuracy log is 6 bits. For more description see the FSE header description</p>
<p>The Huffman header compression uses 2 states, which share the same FSE distribution table. The first state (<span class="tt">State1</span>) encodes the even indexed symbols, and the second (<span class="tt">State2</span>) encodes the odd indexed symbols. <span class="tt">State1</span> is initialized first, and then <span class="tt">State2</span>, and they take turns decoding a single symbol and updating their state. For more details on these FSE operations, see the FSE section.</p>
<p>The number of symbols to decode is determined by tracking bitStream overflow condition: If updating state after decoding a symbol would require more bits than remain in the stream, it is assumed that extra bits are 0. Then, symbols for each of the final states are decoded and the process is complete.</p>
<p>If this process would produce more weights than the maximum number of decoded weights (255), then the data is considered corrupted.</p>
<p>If either of the 2 initial states are absent or truncated, then the data is considered corrupted. Consequently, it is not possible to encode fewer than 2 weights using this mode.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md137"></a>
Conversion from weights to Huffman prefix codes</h3>
<p>All present symbols shall now have a <span class="tt">Weight</span> value. It is possible to transform weights into <span class="tt">Number_of_Bits</span>, using this formula: </p><div class="fragment"><div class="line">Number_of_Bits = (Weight&gt;0) ? Max_Number_of_Bits + 1 - Weight : 0</div>
</div><!-- fragment --><p> In order to determine which prefix code is assigned to each Symbol, Symbols are first sorted by <span class="tt">Weight</span>, then by natural sequential order. Symbols with a <span class="tt">Weight</span> of zero are removed. Then, starting from lowest <span class="tt">Weight</span> (hence highest <span class="tt">Number_of_Bits</span>), prefix codes are assigned in ascending order.</p>
<p><b>Example</b> : Let's assume the following list of weights has been decoded:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Literal  </th><th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">B  </th><th class="markdownTableHeadNone">C  </th><th class="markdownTableHeadNone">D  </th><th class="markdownTableHeadNone">E  </th><th class="markdownTableHeadNone">F  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Weight</span>  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td></tr>
</table>
<p>Sorted by weight and then natural sequential order, it gives the following prefix codes distribution:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Literal  </th><th class="markdownTableHeadNone">D  </th><th class="markdownTableHeadNone">E  </th><th class="markdownTableHeadNone">F  </th><th class="markdownTableHeadNone">C  </th><th class="markdownTableHeadNone">B  </th><th class="markdownTableHeadNone">A  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">Weight</span>  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">4  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Number_of_Bits</span>  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">prefix code  </td><td class="markdownTableBodyNone">N/A  </td><td class="markdownTableBodyNone">0000  </td><td class="markdownTableBodyNone">0001  </td><td class="markdownTableBodyNone">001  </td><td class="markdownTableBodyNone">01  </td><td class="markdownTableBodyNone">1  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ascending order  </td><td class="markdownTableBodyNone">N/A  </td><td class="markdownTableBodyNone">0000  </td><td class="markdownTableBodyNone">0001  </td><td class="markdownTableBodyNone">001x  </td><td class="markdownTableBodyNone">01xx  </td><td class="markdownTableBodyNone">1xxx  </td></tr>
</table>
<h2 class="doxsection"><a class="anchor" id="autotoc_md138"></a>
Huffman-coded Streams</h2>
<p>Given a Huffman decoding table, it's possible to decode a Huffman-coded stream.</p>
<p>Each bitstream must be read <em>backward</em>, that is starting from the end down to the beginning. Therefore it's necessary to know the size of each bitstream.</p>
<p>It's also necessary to know exactly which <em>bit</em> is the last one. This is detected by a final bit flag : the highest bit of latest byte is a final-bit-flag. Consequently, a last byte of <span class="tt">0</span> is not possible. And the final-bit-flag itself is not part of the useful bitstream. Hence, the last byte contains between 0 and 7 useful bits.</p>
<p>Starting from the end, it's possible to read the bitstream in a <b>little-endian</b> fashion, keeping track of already used bits. Since the bitstream is encoded in reverse order, starting from the end read symbols in forward order.</p>
<p>For example, if the literal sequence <span class="tt">ABEF</span> was encoded using above prefix code, it would be encoded (in reverse order) as:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Symbol  </th><th class="markdownTableHeadNone">F  </th><th class="markdownTableHeadNone">E  </th><th class="markdownTableHeadNone">B  </th><th class="markdownTableHeadNone">A  </th><th class="markdownTableHeadNone">Padding  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Encoding  </td><td class="markdownTableBodyNone"><span class="tt">0000</span>  </td><td class="markdownTableBodyNone"><span class="tt">0001</span>  </td><td class="markdownTableBodyNone"><span class="tt">01</span>  </td><td class="markdownTableBodyNone"><span class="tt">1</span>  </td><td class="markdownTableBodyNone"><span class="tt">00001</span>  </td></tr>
</table>
<p>Resulting in following 2-bytes bitstream : </p><div class="fragment"><div class="line">00010000 00001101</div>
</div><!-- fragment --><p>Here is an alternative representation with the symbol codes separated by underscore: </p><div class="fragment"><div class="line">0001_0000 00001_1_01</div>
</div><!-- fragment --><p>Reading highest <span class="tt">Max_Number_of_Bits</span> bits, it's possible to compare extracted value to decoding table, determining the symbol to decode and number of bits to discard.</p>
<p>The process continues up to reading the required number of symbols per stream. If a bitstream is not entirely and exactly consumed, hence reaching exactly its beginning position with <em>all</em> bits consumed, the decoding process is considered faulty.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md139"></a>
Dictionary Format</h1>
<p>Zstandard is compatible with "raw content" dictionaries, free of any format restriction, except that they must be at least 8 bytes. These dictionaries function as if they were just the <span class="tt">Content</span> part of a formatted dictionary.</p>
<p>But dictionaries created by <span class="tt">zstd --train</span> follow a format, described here.</p>
<p><b>Pre-requisites</b> : a dictionary has a size, defined either by a buffer limit, or a file size.</p>
<p>| <span class="tt">Magic_Number</span> | <span class="tt">Dictionary_ID</span> | <span class="tt">Entropy_Tables</span> | <span class="tt">Content</span> | | -----------&mdash; | ------------&mdash; | -------------&mdash; | ------&mdash; |</p>
<p><b><span class="tt">Magic_Number</span></b> : 4 bytes ID, value 0xEC30A437, <b>little-endian</b> format</p>
<p><b><span class="tt">Dictionary_ID</span></b> : 4 bytes, stored in <b>little-endian</b> format. <span class="tt">Dictionary_ID</span> can be any value, except 0 (which means no <span class="tt">Dictionary_ID</span>). It's used by decoders to check if they use the correct dictionary.</p>
<p><em>Reserved ranges :</em> If the dictionary is going to be distributed in a public environment, the following ranges of <span class="tt">Dictionary_ID</span> are reserved for some future registrar and shall not be used : </p><pre class="fragment">- low range  : &lt;= 32767
- high range : &gt;= (2^31)
</pre><p>Outside of these ranges, any value of <span class="tt">Dictionary_ID</span> which is both <span class="tt">&gt;= 32768</span> and <span class="tt">&lt; (1&lt;&lt;31)</span> can be used freely, even in public environment.</p>
<p><b><span class="tt">Entropy_Tables</span></b> : follow the same format as tables in compressed blocks. See the relevant FSE and Huffman sections for how to decode these tables. They are stored in following order : Huffman tables for literals, FSE table for offsets, FSE table for match lengths, and FSE table for literals lengths. These tables populate the Repeat Stats literals mode and Repeat distribution mode for sequence decoding. It's finally followed by 3 offset values, populating recent offsets (instead of using <span class="tt">{1,4,8}</span>), stored in order, 4-bytes <b>little-endian</b> each, for a total of 12 bytes. Each recent offset must have a value &lt;= dictionary content size, and cannot equal 0.</p>
<p><b><span class="tt">Content</span></b> : The rest of the dictionary is its content. The content act as a "past" in front of data to compress or decompress, so it can be referenced in sequence commands. As long as the amount of data decoded from this frame is less than or equal to <span class="tt">Window_Size</span>, sequence commands may specify offsets longer than the total length of decoded output so far to reference back to the dictionary, even parts of the dictionary with offsets larger than <span class="tt">Window_Size</span>. After the total output has surpassed <span class="tt">Window_Size</span> however, this is no longer allowed and the dictionary is no longer accessible.</p>
<p>If a dictionary is provided by an external source, it should be loaded with great care, its content considered untrusted.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md140"></a>
Appendix A - Decoding tables for predefined codes</h1>
<p>This appendix contains FSE decoding tables for the predefined literal length, match length, and offset codes. The tables have been constructed using the algorithm as given above in chapter "from normalized distribution to decoding tables". The tables here can be used as examples to crosscheck that an implementation build its decoding tables correctly.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md141"></a>
Literal Length Code:</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State  </th><th class="markdownTableHeadNone">Symbol  </th><th class="markdownTableHeadNone">Number_Of_Bits  </th><th class="markdownTableHeadNone">Base  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">19  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">21  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">17  </td><td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">26  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">19  </td><td class="markdownTableBodyNone">27  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">29  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">21  </td><td class="markdownTableBodyNone">31  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">23  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">26  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">27  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">28  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">29  </td><td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">30  </td><td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">31  </td><td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">33  </td><td class="markdownTableBodyNone">17  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">34  </td><td class="markdownTableBodyNone">19  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">35  </td><td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">36  </td><td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">37  </td><td class="markdownTableBodyNone">23  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">38  </td><td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">39  </td><td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">40  </td><td class="markdownTableBodyNone">26  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">41  </td><td class="markdownTableBodyNone">28  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">42  </td><td class="markdownTableBodyNone">30  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">43  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">48  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">44  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">45  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">46  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">47  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">48  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">49  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">50  </td><td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">51  </td><td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">52  </td><td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">53  </td><td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">54  </td><td class="markdownTableBodyNone">17  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">55  </td><td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">56  </td><td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">57  </td><td class="markdownTableBodyNone">21  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">58  </td><td class="markdownTableBodyNone">23  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">59  </td><td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">60  </td><td class="markdownTableBodyNone">35  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">61  </td><td class="markdownTableBodyNone">34  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">62  </td><td class="markdownTableBodyNone">33  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">63  </td><td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md142"></a>
Match Length Code:</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State  </th><th class="markdownTableHeadNone">Symbol  </th><th class="markdownTableHeadNone">Number_Of_Bits  </th><th class="markdownTableHeadNone">Base  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">19  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">28  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">31  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">33  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">35  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">17  </td><td class="markdownTableBodyNone">37  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">39  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">19  </td><td class="markdownTableBodyNone">41  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">43  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">21  </td><td class="markdownTableBodyNone">45  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">23  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">26  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">27  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">28  </td><td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">29  </td><td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">30  </td><td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">31  </td><td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">21  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">33  </td><td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">34  </td><td class="markdownTableBodyNone">27  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">35  </td><td class="markdownTableBodyNone">30  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">36  </td><td class="markdownTableBodyNone">32  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">37  </td><td class="markdownTableBodyNone">34  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">38  </td><td class="markdownTableBodyNone">36  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">39  </td><td class="markdownTableBodyNone">38  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">40  </td><td class="markdownTableBodyNone">40  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">41  </td><td class="markdownTableBodyNone">42  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">42  </td><td class="markdownTableBodyNone">44  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">43  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">44  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">48  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">45  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">46  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">47  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">48  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">49  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">32  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">50  </td><td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">51  </td><td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">52  </td><td class="markdownTableBodyNone">17  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">53  </td><td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">54  </td><td class="markdownTableBodyNone">23  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">55  </td><td class="markdownTableBodyNone">26  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">56  </td><td class="markdownTableBodyNone">29  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">57  </td><td class="markdownTableBodyNone">52  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">58  </td><td class="markdownTableBodyNone">51  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">59  </td><td class="markdownTableBodyNone">50  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">60  </td><td class="markdownTableBodyNone">49  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">61  </td><td class="markdownTableBodyNone">48  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">62  </td><td class="markdownTableBodyNone">47  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">63  </td><td class="markdownTableBodyNone">46  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">0  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md143"></a>
Offset Code:</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">State  </th><th class="markdownTableHeadNone">Symbol  </th><th class="markdownTableHeadNone">Number_Of_Bits  </th><th class="markdownTableHeadNone">Base  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">0  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">21  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">3  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9  </td><td class="markdownTableBodyNone">23  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12  </td><td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">14  </td><td class="markdownTableBodyNone">2  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">15  </td><td class="markdownTableBodyNone">7  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">11  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">17  </td><td class="markdownTableBodyNone">17  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">18  </td><td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">19  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">20  </td><td class="markdownTableBodyNone">8  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">21  </td><td class="markdownTableBodyNone">13  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">22  </td><td class="markdownTableBodyNone">19  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">23  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">6  </td><td class="markdownTableBodyNone">4  </td><td class="markdownTableBodyNone">16  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">10  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">26  </td><td class="markdownTableBodyNone">16  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">27  </td><td class="markdownTableBodyNone">28  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">28  </td><td class="markdownTableBodyNone">27  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">29  </td><td class="markdownTableBodyNone">26  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">30  </td><td class="markdownTableBodyNone">25  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">31  </td><td class="markdownTableBodyNone">24  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">0  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="autotoc_md144"></a>
Appendix B - Resources for implementers</h1>
<p>An open source reference implementation is available on : <a href="https://github.com/facebook/zstd">https://github.com/facebook/zstd</a></p>
<p>The project contains a frame generator, called <a href="https://github.com/facebook/zstd/tree/v1.3.4/tests#decodecorpus---tool-to-generate-zstandard-frames-for-decoder-testing">decodeCorpus</a>, which can be used by any 3rd-party implementation to verify that a tested decoder is compliant with the specification.</p>
<p><span class="tt">decodeCorpus</span> generates random valid frames. A compliant decoder should be able to decode them all, or at least provide a meaningful error code explaining for which reason it cannot (memory limit restrictions for example).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md145"></a>
Version changes</h1>
<ul>
<li>0.4.3 : clarifications for Huffman prefix code assignment example</li>
<li>0.4.2 : refactor FSE table construction process, inspired by Donald Pian</li>
<li>0.4.1 : clarifications on a few error scenarios, by Eric Lasota</li>
<li>0.4.0 : fixed imprecise behavior for nbSeq==0, detected by Igor Pavlov</li>
<li>0.3.9 : clarifications for Huffman-compressed literal sizes.</li>
<li>0.3.8 : clarifications for Huffman Blocks and Huffman Tree descriptions.</li>
<li>0.3.7 : clarifications for Repeat_Offsets, matching RFC8878</li>
<li>0.3.6 : clarifications for Dictionary_ID</li>
<li>0.3.5 : clarifications for Block_Maximum_Size</li>
<li>0.3.4 : clarifications for FSE decoding table</li>
<li>0.3.3 : clarifications for field Block_Size</li>
<li>0.3.2 : remove additional block size restriction on compressed blocks</li>
<li>0.3.1 : minor clarification regarding offset history update rules</li>
<li>0.3.0 : minor edits to match RFC8478</li>
<li>0.2.9 : clarifications for huffman weights direct representation, by Ulrich Kunitz</li>
<li>0.2.8 : clarifications for IETF RFC discuss</li>
<li>0.2.7 : clarifications from IETF RFC review, by Vijay Gurbani and Nick Terrell</li>
<li>0.2.6 : fixed an error in huffman example, by Ulrich Kunitz</li>
<li>0.2.5 : minor typos and clarifications</li>
<li>0.2.4 : section restructuring, by Sean Purcell</li>
<li>0.2.3 : clarified several details, by Sean Purcell</li>
<li>0.2.2 : added predefined codes, by Johannes Rudolph</li>
<li>0.2.1 : clarify field names, by Przemyslaw Skibinski</li>
<li>0.2.0 : numerous format adjustments for zstd v0.8+</li>
<li>0.1.2 : limit Huffman tree depth to 11 bits</li>
<li>0.1.1 : reserved dictID ranges</li>
<li>0.1.0 : initial release </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
