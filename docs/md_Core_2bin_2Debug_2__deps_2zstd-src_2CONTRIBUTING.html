<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VEX Engine: Contributing to Zstandard</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="RenderedLogoLowRes.png"/></td>
  <td id="projectalign">
   <div id="projectname">VEX Engine
   </div>
   <div id="projectbrief">Retro looking game engine made in vulkan mostly because i wanted to understand it better.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_Core_2bin_2Debug_2__deps_2zstd-src_2CONTRIBUTING.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Contributing to Zstandard </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md49"></a></p>
<p>We want to make contributing to this project as easy and transparent as possible.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md50"></a>
Our Development Process</h1>
<p>New versions are being developed in the "dev" branch, or in their own feature branch. When they are deemed ready for a release, they are merged into "release".</p>
<p>As a consequence, all contributions must stage first through "dev" or their own feature branch.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md51"></a>
Pull Requests</h1>
<p>We actively welcome your pull requests.</p>
<ol type="1">
<li>Fork the repo and create your branch from <span class="tt">dev</span>.</li>
<li>If you've added code that should be tested, add tests.</li>
<li>If you've changed APIs, update the documentation.</li>
<li>Ensure the test suite passes.</li>
<li>Make sure your code lints.</li>
<li>If you haven't already, complete the Contributor License Agreement ("CLA").</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md52"></a>
Contributor License Agreement ("CLA")</h1>
<p>In order to accept your pull request, we need you to submit a CLA. You only need to do this once to work on any of Facebook's open source projects.</p>
<p>Complete your CLA here: <a href="https://code.facebook.com/cla">https://code.facebook.com/cla</a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md53"></a>
Workflow</h1>
<p>Zstd uses a branch-based workflow for making changes to the codebase. Typically, zstd will use a new branch per sizable topic. For smaller changes, it is okay to lump multiple related changes into a branch.</p>
<p>Our contribution process works in three main stages:</p><ol type="1">
<li>Local development<ul>
<li>Update:<ul>
<li>Checkout your fork of zstd if you have not already <div class="fragment"><div class="line">git checkout https://github.com/&lt;username&gt;/zstd</div>
<div class="line">cd zstd</div>
</div><!-- fragment --></li>
<li>Update your local dev branch <div class="fragment"><div class="line">git pull https://github.com/facebook/zstd dev</div>
<div class="line">git push origin dev</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Topic and development:<ul>
<li>Make a new branch on your fork about the topic you're developing for <div class="fragment"><div class="line"># branch names should be concise but sufficiently informative</div>
<div class="line">git checkout -b &lt;branch-name&gt;</div>
<div class="line">git push origin &lt;branch-name&gt;</div>
</div><!-- fragment --></li>
<li>Make commits and push <div class="fragment"><div class="line"># make some changes =</div>
<div class="line">git add -u &amp;&amp; git commit -m &lt;message&gt;</div>
<div class="line">git push origin &lt;branch-name&gt;</div>
</div><!-- fragment --></li>
<li>Note: run local tests to ensure that your changes didn't break existing functionality<ul>
<li>Quick check <span class="tt">
            make check
            </span></li>
<li>Longer check <span class="tt">
            make test
            </span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Code Review and CI tests<ul>
<li>Ensure CI tests pass:<ul>
<li>Before sharing anything to the community, create a pull request in your own fork against the dev branch and make sure that all GitHub Actions CI tests pass. See the Continuous Integration section below for more information.</li>
<li>Ensure that static analysis passes on your development machine. See the Static Analysis section below to see how to do this.</li>
</ul>
</li>
<li>Create a pull request:<ul>
<li>When you are ready to share you changes to the community, create a pull request from your branch to facebook:dev. You can do this very easily by clicking 'Create Pull Request' on your fork's home page.</li>
<li>From there, select the branch where you made changes as your source branch and facebook:dev as the destination.</li>
<li>Examine the diff presented between the two branches to make sure there is nothing unexpected.</li>
</ul>
</li>
<li>Write a good pull request description:<ul>
<li>While there is no strict template that our contributors follow, we would like them to sufficiently summarize and motivate the changes they are proposing. We recommend all pull requests, at least indirectly, address the following points.<ul>
<li>Is this pull request important and why?</li>
<li>Is it addressing an issue? If so, what issue? (provide links for convenience please)</li>
<li>Is this a new feature? If so, why is it useful and/or necessary?</li>
<li>Are there background references and documents that reviewers should be aware of to properly assess this change?</li>
</ul>
</li>
<li>Note: make sure to point out any design and architectural decisions that you made and the rationale behind them.</li>
<li>Note: if you have been working with a specific user and would like them to review your work, make sure you mention them using (&lt;username&gt;)</li>
</ul>
</li>
<li>Submit the pull request and iterate with feedback.</li>
</ul>
</li>
<li>Merge and Release<ul>
<li>Getting approval:<ul>
<li>You will have to iterate on your changes with feedback from other collaborators to reach a point where your pull request can be safely merged.</li>
<li>To avoid too many comments on style and convention, make sure that you have a look at our style section below before creating a pull request.</li>
<li>Eventually, someone from the zstd team will approve your pull request and not long after merge it into the dev branch.</li>
</ul>
</li>
<li>Housekeeping:<ul>
<li>Most PRs are linked with one or more Github issues. If this is the case for your PR, make sure the corresponding issue is mentioned. If your change 'fixes' or completely addresses the issue at hand, then please indicate this by requesting that an issue be closed by commenting.</li>
<li>Just because your changes have been merged does not mean the topic or larger issue is complete. Remember that the change must make it to an official zstd release for it to be meaningful. We recommend that contributors track the activity on their pull request and corresponding issue(s) page(s) until their change makes it to the next release of zstd. Users will often discover bugs in your code or suggest ways to refine and improve your initial changes even after the pull request is merged.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md54"></a>
Static Analysis</h1>
<p>Static analysis is a process for examining the correctness or validity of a program without actually executing it. It usually helps us find many simple bugs. Zstd uses clang's <span class="tt">scan-build</span> tool for static analysis. You can install it by following the instructions for your OS on <a href="https://clang-analyzer.llvm.org/scan-build">https://clang-analyzer.llvm.org/scan-build</a>.</p>
<p>Once installed, you can ensure that our static analysis tests pass on your local development machine by running: </p><div class="fragment"><div class="line">make staticAnalyze</div>
</div><!-- fragment --><p>In general, you can use <span class="tt">scan-build</span> to static analyze any build script. For example, to static analyze just <span class="tt">contrib/largeNbDicts</span> and nothing else, you can run:</p>
<div class="fragment"><div class="line">scan-build make -C contrib/largeNbDicts largeNbDicts</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md55"></a>
Pitfalls of static analysis</h2>
<p><span class="tt">scan-build</span> is part of our regular CI suite. Other static analyzers are not.</p>
<p>It can be useful to look at additional static analyzers once in a while (and we do), but it's not a good idea to multiply the nb of analyzers run continuously at each commit and PR. The reasons are :</p>
<ul>
<li>Static analyzers are full of false positive. The signal to noise ratio is actually pretty low.</li>
<li>A good CI policy is "zero-warning tolerance". That means that all issues must be solved, including false positives. This quickly becomes a tedious workload.</li>
<li>Multiple static analyzers will feature multiple kind of false positives, sometimes applying to the same code but in different ways leading to :<ul>
<li>tortuous code, trying to please multiple constraints, hurting readability and therefore maintenance. Sometimes, such complexity introduce other more subtle bugs, that are just out of scope of the analyzers.</li>
<li>sometimes, these constraints are mutually exclusive : if one try to solve one, the other static analyzer will complain, they can't be both happy at the same time.</li>
</ul>
</li>
<li>As if that was not enough, the list of false positives change with each version. It's hard enough to follow one static analyzer, but multiple ones with their own update agenda, this quickly becomes a massive velocity reducer.</li>
</ul>
<p>This is different from running a static analyzer once in a while, looking at the output, and <b>cherry picking</b> a few warnings that seem helpful, either because they detected a genuine risk of bug, or because it helps expressing the code in a way which is more readable or more difficult to misuse. These kinds of reports can be useful, and are accepted.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md56"></a>
Continuous Integration</h1>
<p>CI tests run every time a pull request (PR) is created or updated. The exact tests that get run will depend on the destination branch you specify. Some tests take longer to run than others. Currently, our CI is set up to run a short series of tests when creating a PR to the dev branch and a longer series of tests when creating a PR to the release branch. You can look in the configuration files of the respective CI platform for more information on what gets run when.</p>
<p>Most people will just want to create a PR with the destination set to their local dev branch of zstd. You can then find the status of the tests on the PR's page. You can also re-run tests and cancel running tests from the PR page or from the respective CI's dashboard.</p>
<p>Almost all of zstd's CI runs on GitHub Actions (configured at <span class="tt">.github/workflows</span>), which will automatically run on PRs to your own fork. A small number of tests run on other services (e.g. Travis CI, Circle CI, Appveyor). These require work to set up on your local fork, and (at least for Travis CI) cost money. Therefore, if the PR on your local fork passes GitHub Actions, feel free to submit a PR against the main repo.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md57"></a>
Third-party CI</h2>
<p>A small number of tests cannot run on GitHub Actions, or have yet to be migrated. For these, we use a variety of third-party services (listed below). It is not necessary to set these up on your fork in order to contribute to zstd; however, we do link to instructions for those who want earlier signal.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Service  </th><th class="markdownTableHeadNone">Purpose  </th><th class="markdownTableHeadNone">Setup Links  </th><th class="markdownTableHeadNone">Config Path  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Travis CI  </td><td class="markdownTableBodyNone">Used for testing on non-x86 architectures such as PowerPC  </td><td class="markdownTableBodyNone"><a href="https://docs.travis-ci.com/user/tutorial/#to-get-started-with-travis-ci-using-github">https://docs.travis-ci.com/user/tutorial/#to-get-started-with-travis-ci-using-github</a> <br  />
 <a href="https://github.com/marketplace/travis-ci">https://github.com/marketplace/travis-ci</a>  </td><td class="markdownTableBodyNone"><span class="tt">.travis.yml</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">AppVeyor  </td><td class="markdownTableBodyNone">Used for some Windows testing (e.g. cygwin, mingw)  </td><td class="markdownTableBodyNone"><a href="https://www.appveyor.com/blog/2018/10/02/github-apps-integration/">https://www.appveyor.com/blog/2018/10/02/github-apps-integration/</a> <br  />
 <a href="https://github.com/marketplace/appveyor">https://github.com/marketplace/appveyor</a>  </td><td class="markdownTableBodyNone"><span class="tt">appveyor.yml</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Cirrus CI  </td><td class="markdownTableBodyNone">Used for testing on FreeBSD  </td><td class="markdownTableBodyNone"><a href="https://github.com/marketplace/cirrus-ci/">https://github.com/marketplace/cirrus-ci/</a>  </td><td class="markdownTableBodyNone"><span class="tt">.cirrus.yml</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Circle CI  </td><td class="markdownTableBodyNone">Historically was used to provide faster signal,<br  />
 but we may be able to migrate these to Github Actions  </td><td class="markdownTableBodyNone"><a href="https://circleci.com/docs/2.0/getting-started/#setting-up-circleci">https://circleci.com/docs/2.0/getting-started/#setting-up-circleci</a> <br  />
 <a href="https://youtu.be/Js3hMUsSZ2c">https://youtu.be/Js3hMUsSZ2c</a> <br  />
 <a href="https://circleci.com/docs/2.0/enable-checks/">https://circleci.com/docs/2.0/enable-checks/</a>  </td><td class="markdownTableBodyNone"><span class="tt">.circleci/config.yml</span>  </td></tr>
</table>
<p>Note: the instructions linked above mostly cover how to set up a repository with CI from scratch. The general idea should be the same for setting up CI on your fork of zstd, but you may have to follow slightly different steps. In particular, please ignore any instructions related to setting up config files (since zstd already has configs for each of these services).</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md58"></a>
Performance</h1>
<p>Performance is extremely important for zstd and we only merge pull requests whose performance landscape and corresponding trade-offs have been adequately analyzed, reproduced, and presented. This high bar for performance means that every PR which has the potential to impact performance takes a very long time for us to properly review. That being said, we always welcome contributions to improve performance (or worsen performance for the trade-off of something else). Please keep the following in mind before submitting a performance related PR:</p>
<ol type="1">
<li>Zstd isn't as old as gzip but it has been around for time now and its evolution is very well documented via past Github issues and pull requests. It may be the case that your particular performance optimization has already been considered in the past. Please take some time to search through old issues and pull requests using keywords specific to your would-be PR. Of course, just because a topic has already been discussed (and perhaps rejected on some grounds) in the past, doesn't mean it isn't worth bringing up again. But even in that case, it will be helpful for you to have context from that topic's history before contributing.</li>
<li>The distinction between noise and actual performance gains can unfortunately be very subtle especially when microbenchmarking extremely small wins or losses. The only remedy to getting something subtle merged is extensive benchmarking. You will be doing us a great favor if you take the time to run extensive, long-duration, and potentially cross-(os, platform, process, etc) benchmarks on your end before submitting a PR. Of course, you will not be able to benchmark your changes on every single processor and os out there (and neither will we) but do that best you can:) We've added some things to think about when benchmarking below in the Benchmarking Performance section which might be helpful for you.</li>
<li>Optimizing performance for a certain OS, processor vendor, compiler, or network system is a perfectly legitimate thing to do as long as it does not harm the overall performance health of Zstd. This is a hard balance to strike but please keep in mind other aspects of Zstd when submitting changes that are clang-specific, windows-specific, etc.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md59"></a>
Benchmarking Performance</h1>
<p>Performance microbenchmarking is a tricky subject but also essential for Zstd. We value empirical testing over theoretical speculation. This guide it not perfect but for most scenarios, it is a good place to start.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md60"></a>
Stability</h2>
<p>Unfortunately, the most important aspect in being able to benchmark reliably is to have a stable benchmarking machine. A virtual machine, a machine with shared resources, or your laptop will typically not be stable enough to obtain reliable benchmark results. If you can get your hands on a desktop, this is usually a better scenario.</p>
<p>Of course, benchmarking can be done on non-hyper-stable machines as well. You will just have to do a little more work to ensure that you are in fact measuring the changes you've made and not noise. Here are some things you can do to make your benchmarks more stable:</p>
<ol type="1">
<li>The most simple thing you can do to drastically improve the stability of your benchmark is to run it multiple times and then aggregate the results of those runs. As a general rule of thumb, the smaller the change you are trying to measure, the more samples of benchmark runs you will have to aggregate over to get reliable results. Here are some additional things to keep in mind when running multiple trials:<ul>
<li>How you aggregate your samples are important. You might be tempted to use the mean of your results. While this is certainly going to be a more stable number than a raw single sample benchmark number, you might have more luck by taking the median. The mean is not robust to outliers whereas the median is. Better still, you could simply take the fastest speed your benchmark achieved on each run since that is likely the fastest your process will be capable of running your code. In our experience, this (aggregating by just taking the sample with the fastest running time) has been the most stable approach.</li>
<li>The more samples you have, the more stable your benchmarks should be. You can verify your improved stability by looking at the size of your confidence intervals as you increase your sample count. These should get smaller and smaller. Eventually hopefully smaller than the performance win you are expecting.</li>
<li>Most processors will take some time to get <span class="tt">hot</span> when running anything. The observations you collect during that time period will very different from the true performance number. Having a very large number of sample will help alleviate this problem slightly but you can also address is directly by simply not including the first <span class="tt">n</span> iterations of your benchmark in your aggregations. You can determine <span class="tt">n</span> by simply looking at the results from each iteration and then hand picking a good threshold after which the variance in results seems to stabilize.</li>
</ul>
</li>
<li>You cannot really get reliable benchmarks if your host machine is simultaneously running another cpu/memory-intensive application in the background. If you are running benchmarks on your personal laptop for instance, you should close all applications (including your code editor and browser) before running your benchmarks. You might also have invisible background applications running. You can see what these are by looking at either Activity Monitor on Mac or Task Manager on Windows. You will get more stable benchmark results of you end those processes as well.<ul>
<li>If you have multiple cores, you can even run your benchmark on a reserved core to prevent pollution from other OS and user processes. There are a number of ways to do this depending on your OS:<ul>
<li>On linux boxes, you have use <a href="https://github.com/lpechacek/cpuset">https://github.com/lpechacek/cpuset</a>.</li>
<li>On Windows, you can "Set Processor Affinity" using <a href="https://www.thewindowsclub.com/processor-affinity-windows">https://www.thewindowsclub.com/processor-affinity-windows</a></li>
<li>On Mac, you can try to use their dedicated affinity API <a href="https://developer.apple.com/library/archive/releasenotes/Performance/RN-AffinityAPI/#//apple_ref/doc/uid/TP40006635-CH1-DontLinkElementID_2">https://developer.apple.com/library/archive/releasenotes/Performance/RN-AffinityAPI/#//apple_ref/doc/uid/TP40006635-CH1-DontLinkElementID_2</a></li>
</ul>
</li>
</ul>
</li>
<li>To benchmark, you will likely end up writing a separate c/c++ program that will link libzstd. Dynamically linking your library will introduce some added variation (not a large amount but definitely some). Statically linking libzstd will be more stable. Static libraries should be enabled by default when building zstd.</li>
<li>Use a profiler with a good high resolution timer. See the section below on profiling for details on this.</li>
<li>Disable frequency scaling, turbo boost and address space randomization (this will vary by OS)</li>
<li>Try to avoid storage. On some systems you can use tmpfs. Putting the program, inputs and outputs on tmpfs avoids touching a real storage system, which can have a pretty big variability.</li>
</ol>
<p>Also check our LLVM's guide on benchmarking here: <a href="https://llvm.org/docs/Benchmarking.html">https://llvm.org/docs/Benchmarking.html</a></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md61"></a>
Zstd benchmark</h2>
<p>The fastest signal you can get regarding your performance changes is via the in-build zstd cli bench option. You can run Zstd as you typically would for your scenario using some set of options and then additionally also specify the <span class="tt">-b#</span> option. Doing this will run our benchmarking pipeline for that options you have just provided. If you want to look at the internals of how this benchmarking script works, you can check out <a class="el" href="benchzstd_8c_source.html">programs/benchzstd.c</a></p>
<p>For example: say you have made a change that you believe improves the speed of zstd level 1. The very first thing you should use to assess whether you actually achieved any sort of improvement is <span class="tt">zstd -b</span>. You might try to do something like this. Note: you can use the <span class="tt">-i</span> option to specify a running time for your benchmark in seconds (default is 3 seconds). Usually, the longer the running time, the more stable your results will be.</p>
<div class="fragment"><div class="line">$ git checkout &lt;commit-before-your-change&gt;</div>
<div class="line">$ make &amp;&amp; cp zstd zstd-old</div>
<div class="line">$ git checkout &lt;commit-after-your-change&gt;</div>
<div class="line">$ make &amp;&amp; cp zstd zstd-new</div>
<div class="line">$ zstd-old -i5 -b1 &lt;your-test-data&gt;</div>
<div class="line"> 1&lt;your-test-data&gt;         :      8990 -&gt;      3992 (2.252), 302.6 MB/s , 626.4 MB/s</div>
<div class="line">$ zstd-new -i5 -b1 &lt;your-test-data&gt;</div>
<div class="line"> 1&lt;your-test-data&gt;         :      8990 -&gt;      3992 (2.252), 302.8 MB/s , 628.4 MB/s</div>
</div><!-- fragment --><p>Unless your performance win is large enough to be visible despite the intrinsic noise on your computer, benchzstd alone will likely not be enough to validate the impact of your changes. For example, the results of the example above indicate that effectively nothing changed but there could be a small &lt;3% improvement that the noise on the host machine obscured. So unless you see a large performance win (10-15% consistently) using just this method of evaluation will not be sufficient.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md62"></a>
Profiling</h2>
<p>There are a number of great profilers out there. We're going to briefly mention how you can profile your code using <span class="tt">instruments</span> on mac, <span class="tt">perf</span> on linux and <span class="tt">visual studio profiler</span> on Windows.</p>
<p>Say you have an idea for a change that you think will provide some good performance gains for level 1 compression on Zstd. Typically this means, you have identified a section of code that you think can be made to run faster.</p>
<p>The first thing you will want to do is make sure that the piece of code is actually taking up a notable amount of time to run. It is usually not worth optimizing something which accounts for less than 0.0001% of the total running time. Luckily, there are tools to help with this. Profilers will let you see how much time your code spends inside a particular function. If your target code snippet is only part of a function, it might be worth trying to isolate that snippet by moving it to its own function (this is usually not necessary but might be).</p>
<p>Most profilers (including the profilers discussed below) will generate a call graph of functions for you. Your goal will be to find your function of interest in this call graph and then inspect the time spent inside of it. You might also want to look at the annotated assembly which most profilers will provide you with.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md63"></a>
Instruments</h3>
<p>We will once again consider the scenario where you think you've identified a piece of code whose performance can be improved upon. Follow these steps to profile your code using Instruments.</p>
<ol type="1">
<li>Open Instruments</li>
<li>Select <span class="tt">Time Profiler</span> from the list of standard templates</li>
<li>Close all other applications except for your instruments window and your terminal</li>
<li>Run your benchmarking script from your terminal window<ul>
<li>You will want a benchmark that runs for at least a few seconds (5 seconds will usually be long enough). This way the profiler will have something to work with and you will have ample time to attach your profiler to this process:)</li>
<li>I will just use benchzstd as my benchmarmking script for this example: <div class="fragment"><div class="line">$ zstd -b1 -i5 &lt;my-data&gt; # this will run for 5 seconds</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>Once you run your benchmarking script, switch back over to instruments and attach your process to the time profiler. You can do this by:<ul>
<li>Clicking on the <span class="tt">All Processes</span> drop down in the top left of the toolbar.</li>
<li>Selecting your process from the dropdown. In my case, it is just going to be labeled <span class="tt">zstd</span></li>
<li>Hitting the bright red record circle button on the top left of the toolbar</li>
</ul>
</li>
<li>You profiler will now start collecting metrics from your benchmarking script. Once you think you have collected enough samples (usually this is the case after 3 seconds of recording), stop your profiler.</li>
<li>Make sure that in toolbar of the bottom window, <span class="tt">profile</span> is selected.</li>
<li>You should be able to see your call graph.<ul>
<li>If you don't see the call graph or an incomplete call graph, make sure you have compiled zstd and your benchmarking script using debug flags. On mac and linux, this just means you will have to supply the <span class="tt">-g</span> flag alone with your build script. You might also have to provide the <span class="tt">-fno-omit-frame-pointer</span> flag</li>
</ul>
</li>
<li>Dig down the graph to find your function call and then inspect it by double clicking the list item. You will be able to see the annotated source code and the assembly side by side.</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md64"></a>
Perf</h3>
<p>This wiki has a pretty detailed tutorial on getting started working with perf so we'll leave you to check that out of you're getting started:</p>
<p><a href="https://perf.wiki.kernel.org/index.php/Tutorial">https://perf.wiki.kernel.org/index.php/Tutorial</a></p>
<p>Some general notes on perf:</p><ul>
<li>Use <span class="tt">perf stat -r # &lt;bench-program&gt;</span> to quickly get some relevant timing and counter statistics. Perf uses a high resolution timer and this is likely one of the first things your team will run when assessing your PR.</li>
<li>Perf has a long list of hardware counters that can be viewed with <span class="tt">perf --list</span>. When measuring optimizations, something worth trying is to make sure the hardware counters you expect to be impacted by your change are in fact being so. For example, if you expect the L1 cache misses to decrease with your change, you can look at the counter <span class="tt">L1-dcache-load-misses</span></li>
<li>Perf hardware counters will not work on a virtual machine.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md65"></a>
Visual Studio</h3>
<p>TODO</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md66"></a>
Issues</h1>
<p>We use GitHub issues to track public bugs. Please ensure your description is clear and has sufficient instructions to be able to reproduce the issue.</p>
<p>Facebook has a <a href="https://www.facebook.com/whitehat/">bounty program</a> for the safe disclosure of security bugs. In those cases, please go through the process outlined on that page and do not file a public issue.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md67"></a>
Coding Style</h1>
<p>It's a pretty long topic, which is difficult to summarize in a single paragraph. As a rule of thumbs, try to imitate the coding style of similar lines of codes around your contribution. The following is a non-exhaustive list of rules employed in zstd code base:</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md68"></a>
C90</h2>
<p>This code base is following strict C90 standard, with 2 extensions : 64-bit <span class="tt">long long</span> types, and variadic macros. This rule is applied strictly to code within <span class="tt">lib/</span> and <span class="tt">programs/</span>. Sub-project in <span class="tt">contrib/</span> are allowed to use other conventions.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md69"></a>
C++ direct compatibility : symbol mangling</h2>
<p>All public symbol declarations must be wrapped in <span class="tt">extern “C” { … }</span>, so that this project can be compiled as C++98 code, and linked into C++ applications.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md70"></a>
Minimal Frugal</h2>
<p>This design requirement is fundamental to preserve the portability of the code base. </p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md71"></a>
Dependencies</h3>
<ul>
<li>Reduce dependencies to the minimum possible level. Any dependency should be considered “bad” by default, and only tolerated because it provides a service in a better way than can be achieved locally. The only external dependencies this repository tolerates are standard C libraries, and in rare cases, system level headers.</li>
<li>Within <span class="tt">lib/</span>, this policy is even more drastic. The only external dependencies allowed are <span class="tt">&lt;assert.h&gt;</span>, <span class="tt">&lt;stdlib.h&gt;</span>, <span class="tt">&lt;string.h&gt;</span>, and even then, not directly. In particular, no function shall ever allocate on heap directly, and must use instead <span class="tt">ZSTD_malloc()</span> and equivalent. Other accepted non-symbol headers are <span class="tt">&lt;<a class="el" href="stddef_8h_source.html">stddef.h</a>&gt;</span> and <span class="tt">&lt;<a class="el" href="limits_8h_source.html">limits.h</a>&gt;</span>.</li>
<li>Within the project, there is a strict hierarchy of dependencies that must be respected. <span class="tt">programs/</span> is allowed to depend on <span class="tt">lib/</span>, but only its public API. Within <span class="tt">lib/</span>, <span class="tt">lib/common</span> doesn't depend on any other directory. <span class="tt">lib/compress</span> and <span class="tt">lib/decompress</span> shall not depend on each other. <span class="tt">lib/dictBuilder</span> can depend on <span class="tt">lib/common</span> and <span class="tt">lib/compress</span>, but not <span class="tt">lib/decompress</span>. </li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md72"></a>
Resources</h3>
<ul>
<li>Functions in <span class="tt">lib/</span> must use very little stack space, several dozens of bytes max. Everything larger must use the heap allocator, or require a scratch buffer to be emplaced manually.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md73"></a>
Naming</h2>
<ul>
<li>All public symbols are prefixed with <span class="tt">ZSTD_</span><ul>
<li>private symbols, with a scope limited to their own unit, are free of this restriction. However, since <span class="tt">libzstd</span> source code can be amalgamated, each symbol name must attempt to be (and remain) unique. Avoid too generic names that could become ground for future collisions. This generally implies usage of some form of prefix.</li>
</ul>
</li>
<li>For symbols (functions and variables), naming convention is <span class="tt">PREFIX_camelCase</span>.<ul>
<li>In some advanced cases, one can also find :<ul>
<li><span class="tt">PREFIX_prefix2_camelCase</span></li>
<li><span class="tt">PREFIX_camelCase_extendedQualifier</span></li>
</ul>
</li>
</ul>
</li>
<li>Multi-words names generally consist of an action followed by object:<ul>
<li>for example : <span class="tt">ZSTD_createCCtx()</span></li>
</ul>
</li>
<li>Prefer positive actions<ul>
<li><span class="tt">goBackward</span> rather than <span class="tt">notGoForward</span></li>
</ul>
</li>
<li>Type names (<span class="tt">struct</span>, etc.) follow similar convention, except that they are allowed and even invited to start by an Uppercase letter. Example : <span class="tt">ZSTD_CCtx</span>, <span class="tt">ZSTD_CDict</span></li>
<li>Macro names are all Capital letters. The same composition rules (<span class="tt">PREFIX_NAME_QUALIFIER</span>) apply.</li>
<li>File names are all lowercase letters. The convention is <span class="tt">snake_case</span>. File names <b>must</b> be unique across the entire code base, even when they stand in clearly separated directories.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md74"></a>
Qualifiers</h2>
<ul>
<li>This code base is <span class="tt">const</span> friendly, if not <span class="tt">const</span> fanatical. Any variable that can be <span class="tt">const</span> (aka. read-only) <b>must</b> be <span class="tt">const</span>. Any pointer which content will not be modified must be <span class="tt">const</span>. This property is then controlled at compiler level. <span class="tt">const</span> variables are an important signal to readers that this variable isn't modified. Conversely, non-const variables are a signal to readers to watch out for modifications later on in the function.</li>
<li>If a function must be inlined, mention it explicitly, using project's own portable macros, such as <span class="tt">FORCE_INLINE_ATTR</span>, defined in <span class="tt"><a class="el" href="lib_2common_2compiler_8h_source.html">lib/common/compiler.h</a></span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md75"></a>
Debugging</h2>
<ul>
<li><b>Assertions</b> are welcome, and should be used very liberally, to control any condition the code expects for its correct execution. These assertion checks will be run in debug builds, and disabled in production.</li>
<li>For traces, this project provides its own debug macros, in particular <span class="tt">DEBUGLOG(level, ...)</span>, defined in <span class="tt"><a class="el" href="debug_8h_source.html">lib/common/debug.h</a></span>.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md76"></a>
Code documentation</h2>
<ul>
<li>Avoid code documentation that merely repeats what the code is already stating. Whenever applicable, prefer employing the code as the primary way to convey explanations. Example 1 : <span class="tt">int nbTokens = n;</span> instead of <span class="tt">int i = n; /* i is a nb of tokens *./</span>. Example 2 : <span class="tt">assert(size &gt; 0);</span> instead of <span class="tt">/* here, size should be positive */</span>.</li>
<li>At declaration level, the documentation explains how to use the function or variable and when applicable why it's needed, of the scenarios where it can be useful.</li>
<li>At implementation level, the documentation explains the general outline of the algorithm employed, and when applicable why this specific choice was preferred.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md77"></a>
General layout</h2>
<ul>
<li>4 spaces for indentation rather than tabs</li>
<li>Code documentation shall directly precede function declaration or implementation</li>
<li>Function implementations and its code documentation should be preceded and followed by an empty line</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md78"></a>
License</h1>
<p>By contributing to Zstandard, you agree that your contributions will be licensed under both the [LICENSE](LICENSE) file and the [COPYING](COPYING) file in the root directory of this source tree. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
